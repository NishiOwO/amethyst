//
// ==================================================================================================
// STANDARD LIBRARY STUFFS
// ==================================================================================================
//

// Loops while a condition is true.
(defmacro
    while condy
        stat
    &key else
    (loop
        (cond
            (condy stat)
            (:else (break else)))))

// Performs a short circuiting logical and.
(defmacro
    and x y
    (cond
        (x y)
        (:else 0)))

// Performs a short circuiting logical or.
(defmacro
    or x y
    (cond
        (x 1)
        (:else y)))

// Prints out a string onto stdout.
(defun print (str (@ mut u8))
    (seqn
        (syscall 1 1 (cast str.ptr) str.len 0 0 0)))

// Prints out a number onto stdout.
(defun print-int (i u64)
    (seqn
        (cond
            ((== i 0) (print "0"))
            (:else (seqn
                (let p = (alloca 20))
                (let start = 19)
                (while (!= i 0) (seqn
                    (let c = (+ '0' (cast (% i 10))))
                    (set start = (- start 1))
                    (set (get p start) = c)
                    (set i = (/ i 10))))
                (print (subslice p start (- p.len 1))))))))

// Prints out a string onto stderr.
(defun eprint (str (@ mut u8))
    (seqn
        (syscall 1 2 (cast str.ptr) str.len 0 0 0)))

// Exits the program
(defun exit (code i32)
    (seqn
        (syscall 60 (cast code) 0 0 0 0 0)))

// Creates a subslice from a given slice and range.
(defun subslice (s (@ mut 'a)) (start u64) (end u64) : (@ mut 'a)
    (slice (- end start) (ptr-add s.ptr start)))

// Defines a file (wrapper around a file descriptor).
(defstruct File
    (descriptor i32))

(defun file-is-valid (file File) : u1
    (!= file.descriptor (- 0 1)))

(defmacro FILE_OPEN_FLAG_READ_ONLY 0)

// Opens a file.
(defun file-open (path (@ mut u8)) (flags u64) : File
    (seq
        (let null-term = (alloca (+ path.len 1)))
        (let i = 0)
        (while (< i path.len)
            (seqn
                (set (get null-term i) = (get path i))
                (set i = (+ i 1))))
        (set (get null-term i) = '\0')
        (inst File
            (descriptor
                (cast (syscall 2 (cast null-term.ptr) flags 0 0 0 0))))))

// Reads a file into a vec of u8s.
(defun file-read-all (file File) (A (* mut Allocator)) : (Vec u8) (seq
    (let vec = (ref (new-vec A)))
    (let slice = (alloca 64))
    (while (let len = (syscall 0 (cast file.descriptor) (cast slice.ptr) slice.len 0 0 0)) (seqn
        (let i = 0)
        (while (< i len) (seqn
            (vec-push vec (get slice i))
            (set i = (+ i 1))))))
    (deref vec)))

// Closes a previously opened file.
(defun file-close (file File)
    (seqn
        (syscall 3 (cast file.descriptor) 0 0 0 0 0)))

// Maps memory for the program.
(defun mmap (len u64) : (* mut 'a)
    (cast (syscall 9 0 len 3 34 (- 0 1) 0)))

// Unmaps memory previously mapped by mmap.
(defun munmap (addr (* mut 'a)) (len u64)
    (seqn
        (syscall 11 (cast addr) len 0 0 0 0)))

// Creates a null constant.
(defun null : (* mut 'a)
    (cast (: u64 0)))

// Defines a free bucket linked list node for the memory allocator.
(defstruct FreeBucket
    (next (* mut FreeBucket)))

// Defines an allocator.
(defstruct Allocator
    (free16    (* mut FreeBucket))
    (free64    (* mut FreeBucket))
    (free256   (* mut FreeBucket))
    (free1024  (* mut FreeBucket))
    (free4096  (* mut FreeBucket))
    (free16384 (* mut FreeBucket))
    (free65536 (* mut FreeBucket)))

(defun create-buckets (bucket-size u64) : (* mut FreeBucket)
    (seq
        (let p = (: (* mut u8) (mmap 65536)))
        (let i = (- bucket-size (sizeof FreeBucket)))
        (let q = (cast (ptr-add p i)))
        (while (< i 65536) (seqn
            (let q = (: (* mut FreeBucket) (cast (ptr-add p i))))
            (set i = (+ i bucket-size))
            (cond
                ((< i 65536) (seqn
                    (set (deref q).next = (cast (ptr-add p i)))))
                (:else (seqn
                    (set (deref q).next = (null)))))))
        q))

// Helper function for allocation.
(defun alloc-helper (A (* mut Allocator)) (size u64) : (* mut 'a)
    (cond
        ((<= size 8) (seq
            (cond
                ((== (deref A).free16 (null)) (seqn
                    (set (deref A).free16 = (create-buckets 16)))))
            (let ptr = (deref A).free16)
            (set (deref A).free16 = (deref ptr).next)
            (cast (- (: u64 (cast ptr)) 8))))

        ((<= size 56) (seq
            (cond
                ((== (deref A).free64 (null)) (seqn
                    (set (deref A).free64 = (create-buckets 64)))))
            (let ptr = (deref A).free64)
            (set (deref A).free64 = (deref ptr).next)
            (cast (- (: u64 (cast ptr)) 56))))

        ((<= size 248) (seq
            (cond
                ((== (deref A).free256 (null)) (seqn
                    (set (deref A).free256 = (create-buckets 256)))))
            (let ptr = (deref A).free256)
            (set (deref A).free256 = (deref ptr).next)
            (cast (- (: u64 (cast ptr)) 248))))

        ((<= size 1016) (seq
            (cond
                ((== (deref A).free1024 (null)) (seqn
                    (set (deref A).free1024 = (create-buckets 1024)))))
            (let ptr = (deref A).free1024)
            (set (deref A).free1024 = (deref ptr).next)
            (cast (- (: u64 (cast ptr)) 1016))))

        ((<= size 4088) (seq
            (cond
                ((== (deref A).free4096 (null)) (seqn
                    (set (deref A).free4096 = (create-buckets 4096)))))
            (let ptr = (deref A).free4096)
            (set (deref A).free4096 = (deref ptr).next)
            (cast (- (: u64 (cast ptr)) 4088))))

        ((<= size 16376) (seq
            (cond
                ((== (deref A).free16384 (null)) (seqn
                    (set (deref A).free16384 = (create-buckets 16384)))))
            (let ptr = (deref A).free16384)
            (set (deref A).free16384 = (deref ptr).next)
            (cast (- (: u64 (cast ptr)) 16376))))

        ((<= size 65528) (seq
            (cond
                ((== (deref A).free65536 (null)) (seqn
                    (set (deref A).free65536 = (create-buckets 65536)))))
            (let ptr = (deref A).free65536)
            (set (deref A).free65536 = (deref ptr).next)
            (cast (- (: u64 (cast ptr)) 65528))))

        (:else
            (mmap size))))

// Helper function for deallocation.
(defun dealloc-helper (A (* mut Allocator)) (ptr (* mut 'a)) (size u64)
    (cond
        ((<= size 8) (seqn
            (let p = (ptr-add (: (* mut u8) (cast ptr)) 8))
            (let bucket = (: (* mut FreeBucket) (cast p)))
            (set (deref bucket).next = (deref A).free16)
            (set (deref A).free16 = bucket)))

        ((<= size 56) (seqn
            (let p = (ptr-add (: (* mut u8) (cast ptr)) 56))
            (let bucket = (: (* mut FreeBucket) (cast p)))
            (set (deref bucket).next = (deref A).free64)
            (set (deref A).free64 = bucket)))

        ((<= size 248) (seqn
            (let p = (ptr-add (: (* mut u8) (cast ptr)) 248))
            (let bucket = (: (* mut FreeBucket) (cast p)))
            (set (deref bucket).next = (deref A).free256)
            (set (deref A).free256 = bucket)))

        ((<= size 1016) (seqn
            (let p = (ptr-add (: (* mut u8) (cast ptr)) 1016))
            (let bucket = (: (* mut FreeBucket) (cast p)))
            (set (deref bucket).next = (deref A).free1024)
            (set (deref A).free1024 = bucket)))

        ((<= size 4088) (seqn
            (let p = (ptr-add (: (* mut u8) (cast ptr)) 4088))
            (let bucket = (: (* mut FreeBucket) (cast p)))
            (set (deref bucket).next = (deref A).free4096)
            (set (deref A).free4096 = bucket)))

        ((<= size 16376) (seqn
            (let p = (ptr-add (: (* mut u8) (cast ptr)) 16376))
            (let bucket = (: (* mut FreeBucket) (cast p)))
            (set (deref bucket).next = (deref A).free16384)
            (set (deref A).free16384 = bucket)))

        ((<= size 65528) (seqn
            (let p = (ptr-add (: (* mut u8) (cast ptr)) 65528))
            (let bucket = (: (* mut FreeBucket) (cast p)))
            (set (deref bucket).next = (deref A).free65536)
            (set (deref A).free65536 = bucket)))

        (:else
            (munmap ptr size))))

// Allocates a pointer to some data.
(defun alloc (A (* mut Allocator)) : (* mut 'a)
    (alloc-helper A (sizeof 'a)))

// Deallocates a pointer.
(defun dealloc (A (* mut Allocator)) (ptr (* mut 'a))
    (dealloc-helper A ptr (sizeof 'a)))

// Allocates an array of data.
(defun alloc-array (A (* mut Allocator)) (len u64) : (@ mut 'a)
    (slice len (alloc-helper A (* len (sizeof 'a)))))

// Deallocates an array of data.
(defun dealloc-array (A (* mut Allocator)) (s (@ mut 'a))
    (dealloc-helper A s.ptr (* s.len (sizeof 'a))))

// Creates a new empty allocator.
(defun new-alloc : Allocator
    (inst Allocator
        (free16    (null))
        (free64    (null))
        (free256   (null))
        (free1024  (null))
        (free4096  (null))
        (free16384 (null))
        (free65536 (null))))

// Defines a vector (ie a list).
(defstruct Vec
    (vals (@ mut 'a))
    (len u64)
    (A (* mut Allocator)))

// Creates a new empty vector.
(defun new-vec (A (* mut Allocator)) : (Vec 'a)
    (inst Vec
        (vals (slice 0 (null)))
        (len 0)
        (A A)))

// Gets the ith element of a vector.
(defun vec-get (v (* mut (Vec 'a))) (i u64) : (* mut 'a)
    (cond
        ((< i (deref v).len) (ptr-add (deref v).vals.ptr i))
        (:else (null))))

// Pushes a value onto a vector.
(defun vec-push (vec (* mut (Vec 'a))) (v 'a) (seqn
    (cond
        ((<= (deref vec).vals.cap (deref vec).len) (seqn
            (let new-cap = (cond
                ((== (deref vec).vals.cap 0) 8)
                (:else (* (deref vec).vals.cap 2))))
            (let new-vals = (alloc-array (deref vec).A new-cap))
            (let i = 0)
            (while (< i (deref vec).vals.cap) (seqn
                (set (get new-vals i) = (get (deref vec).vals i))
                (set i = (+ i 1))))
            (set (deref vec).vals = new-vals))))
            (set (get (deref vec).vals (deref vec).len) = v)
            (set (deref vec).len = (+ (deref vec).len 1))))

(defun vec-slice (vec (* mut (Vec 'a))) : (@ mut 'a)
    (subslice (deref vec).vals 0 (deref vec).len))



//
// ==================================================================================================
// LEXING
// ==================================================================================================
//

// Defines a location in source code.
(defstruct Location
    (start u64)
    (end u64))

// Defines a token.
(defstruct Token
    (loc Location)
    (type u64)
    (value (@ mut u8)))

(defmacro TOKEN_TYPE_EOF     0)
(defmacro TOKEN_TYPE_INVALID 1)
(defmacro TOKEN_TYPE_LPAREN  2)
(defmacro TOKEN_TYPE_RPAREN  3)

(defstruct Lexer
    (str (Vec u8))
    (pos u64)
    (tokens (Vec Token))
    (token-pos u64))

(defun new-lexer (A (* mut Allocator)) (str (Vec u8)) : Lexer
    (inst Lexer
        (str str)
        (pos 0)
        (tokens (new-vec A))
        (token-pos 0)))

(defun lex (lexer (* mut Lexer)) : Token
    (cond
        ((< (deref lexer).token-pos (deref lexer).tokens.len) (seq
            (let v = (vec-get (ref (deref lexer).tokens) (deref lexer).token-pos))
            (set (deref lexer).token-pos = (+ (deref lexer).token-pos 1))
            (deref v)))
        (:else (seq
            (let i = (deref lexer).pos)
            (let state = 0)
            (let type = (TOKEN_TYPE_INVALID))
            (while (< i (deref lexer).str.len) (seqn
                (let c = (deref (vec-get (ref (deref lexer).str) i)))
                (set i = (+ i 1))
                (cond
                    // Initial state
                    ((== state 0) (cond
                        ((== c 0x28) (seqn
                            (set type = (TOKEN_TYPE_LPAREN))
                            (break)))
                        ((== c 0x29) (seqn
                            (set type = (TOKEN_TYPE_RPAREN))
                            (break)))
                        (:else (break)))))))

            (let start = (deref lexer).pos)
            (set (deref lexer).pos = i)
            (let token = (inst Token
                (loc (inst Location
                    (start start)
                    (end i)))
                (type type)
                (value (subslice (vec-slice (ref (deref lexer).str)) start i))))
            (let token-vec = (ref (deref lexer).tokens))
            (vec-push token-vec token)
            (set (deref lexer).tokens = (deref token-vec))
            token))))

(defun print-token (token Token) (seqn
    (print "Token: ")
    (print-int token.loc.start)
    (print "..")
    (print-int token.loc.end)
    (print " ")
    (cond
        ((== token.type (TOKEN_TYPE_EOF))
            (print "EOF"))
        ((== token.type (TOKEN_TYPE_INVALID))
            (print "INVALID"))
        ((== token.type (TOKEN_TYPE_LPAREN))
            (print "LPAREN"))
        ((== token.type (TOKEN_TYPE_RPAREN))
            (print "RPAREN"))
        (:else
            (print "UNKNOWN")))
    (print " ")
    (print token.value)
    (print "\n")))



//
// ==================================================================================================
// MAIN
// ==================================================================================================
//

(defun main
    (seqn
        (let file = (file-open "examples/ret-69.amy" (FILE_OPEN_FLAG_READ_ONLY)))
        (cond
            ((file-is-valid file)
                (print "opened file!\n"))
            (:else (seq
                (eprint "failed to open file :(\n")
                (exit 1))))
        (let A = (ref (new-alloc)))
        (let contents = (file-read-all file A))
        (file-close file)
        (let lexer = (ref (new-lexer A contents)))
        (let token = (lex lexer))
        (print-token token)))

