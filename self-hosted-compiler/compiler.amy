//
// ==================================================================================================
// STANDARD LIBRARY STUFFS
// ==================================================================================================
//

// Loops while a condition is true.
(defmacro
    while condy
        stat
    &key else
    (loop
        (cond
            (condy stat)
            (:else (break else)))))

// Performs a short circuiting logical and.
(defmacro
    and x y
    (cond
        (x y)
        (:else 0)))

// Performs a short circuiting logical or.
(defmacro
    or x y
    (cond
        (x 1)
        (:else y)))

// Prints out a string onto stdout.
(defun print (str (@ mut u8))
    (seqn
        (syscall 1 1 (cast str.ptr) str.len 0 0 0)))

// Prints out a number onto stdout.
(defun print-int (i u64)
    (seqn
        (cond
            ((== i 0) (print "0\n"))
            (:else (seqn
                (let p = (alloca 21))
                (set (get p 20) = '\n')
                (let start = 20)
                (while (!= i 0) (seqn
                    (let c = (+ '0' (cast (% i 10))))
                    (set start = (- start 1))
                    (set (get p start) = c)
                    (set i = (/ i 10))))
                (print (subslice p start p.len))
                )))))

// Prints out a string onto stderr.
(defun eprint (str (@ mut u8))
    (seqn
        (syscall 1 2 (cast str.ptr) str.len 0 0 0)))

// Exits the program
(defun exit (code i32)
    (seqn
        (syscall 60 (cast code) 0 0 0 0 0)))

// Creates a subslice from a given slice and range.
(defun subslice (s (@ mut 'a)) (start u64) (end u64) : (@ mut 'a)
    (slice (- end start) (ptr-add s.ptr start)))

// Defines a file (wrapper around a file descriptor).
(defstruct File
    (descriptor i32))

(defun file-is-valid (file File) : u1
    (!= file.descriptor (- 0 1)))

(defmacro FILE_OPEN_FLAG_READ_ONLY 0)

// Opens a file.
(defun file-open (path (@ mut u8)) (flags u64) : File
    (seq
        (let null-term = (alloca (+ path.len 1)))
        (let i = 0)
        (while (< i path.len)
            (seqn
                (set (get null-term i) = (get path i))
                (set i = (+ i 1))))
        (set (get null-term i) = '\0')
        (inst File
            (descriptor
                (cast (syscall 2 (cast null-term.ptr) flags 0 0 0 0))))))

// Closes a previously opened file.
(defun file-close (file File)
    (seqn
        (syscall 3 (cast file.descriptor) 0 0 0 0 0)))

// Maps memory for the program.
(defun mmap (len u64) : (* mut 'a)
    (cast (syscall 9 0 len 3 34 (- 0 1) 0)))

// Unmaps memory previously mapped by mmap.
(defun munmap (addr (* mut 'a)) (len u64)
    (seqn
        (syscall 11 (cast addr) len 0 0 0 0)))

// Creates a null constant.
(defun null : (* mut 'a)
    (cast (: u64 0)))

// Defines a free bucket linked list node for the memory allocator.
(defstruct FreeBucket
    (next (* mut FreeBucket)))

// Defines an allocator.
(defstruct Allocator
    (free16    (* mut FreeBucket))
    (free64    (* mut FreeBucket))
    (free256   (* mut FreeBucket))
    (free1024  (* mut FreeBucket))
    (free4096  (* mut FreeBucket))
    (free16384 (* mut FreeBucket))
    (free65536 (* mut FreeBucket)))

(defun create-buckets (bucket-size u64) : (* mut FreeBucket)
    (seq
        (let p = (: (* mut u8) (mmap 65536)))
        (let i = (- bucket-size (sizeof FreeBucket)))
        (let q = (cast (ptr-add p i)))
        (while (< i 65536) (seqn
            (let q = (: (* mut FreeBucket) (cast (ptr-add p i))))
            (set i = (+ i bucket-size))
            (cond
                ((< i 65536) (seqn
                    (set (deref q).next = (cast (ptr-add p i)))))
                (:else (seqn
                    (set (deref q).next = (null)))))))
        q))

// Helper function for allocation.
(defun alloc-helper (A (* mut Allocator)) (size u64) : (* mut 'a)
    (cond
        ((<= size 8) (seq
            (cond
                ((== (deref A).free16 (null)) (seqn
                    (set (deref A).free16 = (create-buckets 16)))))
            (let ptr = (deref A).free16)
            (set (deref A).free16 = (deref ptr).next)
            (cast (- (: u64 (cast ptr)) 8))))
        ((<= size 56) (seq
            (cond
                ((== (deref A).free64 (null)) (seqn
                    (set (deref A).free64 = (create-buckets 64)))))
            (let ptr = (deref A).free64)
            (set (deref A).free64 = (deref ptr).next)
            (cast (- (: u64 (cast ptr)) 56))))

        ((<= size 248) (seq
            (cond
                ((== (deref A).free256 (null)) (seqn
                    (set (deref A).free256 = (create-buckets 256)))))
            (let ptr = (deref A).free256)
            (set (deref A).free256 = (deref ptr).next)
            (cast (- (: u64 (cast ptr)) 248))))
        ((<= size 1016) (seq
            (cond
                ((== (deref A).free1024 (null)) (seqn
                    (set (deref A).free1024 = (create-buckets 1024)))))
            (let ptr = (deref A).free1024)
            (set (deref A).free1024 = (deref ptr).next)
            (cast (- (: u64 (cast ptr)) 1016))))
        ((<= size 4088) (seq
            (cond
                ((== (deref A).free4096 (null)) (seqn
                    (set (deref A).free4096 = (create-buckets 4096)))))
            (let ptr = (deref A).free4096)
            (set (deref A).free4096 = (deref ptr).next)
            (cast (- (: u64 (cast ptr)) 4088))))
        ((<= size 16376) (seq
            (cond
                ((== (deref A).free16384 (null)) (seqn
                    (set (deref A).free16384 = (create-buckets 16384)))))
            (let ptr = (deref A).free16384)
            (set (deref A).free16384 = (deref ptr).next)
            (cast (- (: u64 (cast ptr)) 16376))))
        ((<= size 65528) (seq
            (cond
                ((== (deref A).free65536 (null)) (seqn
                    (set (deref A).free65536 = (create-buckets 65536)))))
            (let ptr = (deref A).free65536)
            (set (deref A).free65536 = (deref ptr).next)
            (cast (- (: u64 (cast ptr)) 65528))))
        (:else
            (mmap size))))

// Helper function for deallocation.
(defun dealloc-helper (A (* mut Allocator)) (ptr (* mut 'a)) (size u64)
    (cond
        ((<= size 8)
            ())
        ((<= size 56)
            ())
        ((<= size 248)
            ())
        ((<= size 1016)
            ())
        ((<= size 4088)
            ())
        ((<= size 16376)
            ())
        ((<= size 65528)
            ())
        (:else
            ())))

// Allocates a pointer to some data.
(defun alloc (A (* mut Allocator)) : (* mut 'a)
    (alloc-helper A (sizeof 'a)))

// Deallocates a pointer.
(defun dealloc (A (* mut Allocator)) (ptr (* mut 'a))
    (dealloc-helper A ptr (sizeof 'a)))

// Allocates an array of data.
(defun alloc-array (A (* mut Allocator)) (len u64) : (@ mut 'a)
    (slice len (alloc-helper A (* len (sizeof 'a)))))

// Deallocates an array of data.
(defun dealloc-array (A (* mut Allocator)) (s (@ mut 'a))
    (dealloc-helper A s.ptr (* s.len (sizeof 'a))))

// Creates a new empty allocator.
(defun new-alloc : Allocator
    (inst Allocator
        (free16    (null))
        (free64    (null))
        (free256   (null))
        (free1024  (null))
        (free4096  (null))
        (free16384 (null))
        (free65536 (null))))



//
// ==================================================================================================
// LEXING
// ==================================================================================================
//

// Defines a location in source code.
(defstruct Location
    (start u64)
    (end u64))

// Defines a token.
(defstruct Token
    (loc Location)
    (type u64)
    (value (@ mut u8)))

(defmacro TOKEN_TYPE_EOF 0)
(defmacro TOKEN_TYPE_INT 1)



//
// ==================================================================================================
// MAIN
// ==================================================================================================
//

(defun main
    (seqn
        (print "hewo\n")
        (let file = (file-open "self-hosted-compiler/compiler.amy" (FILE_OPEN_FLAG_READ_ONLY)))
        (cond
            ((file-is-valid file)
                (print "opened file!\n"))
            (:else (seq
                (eprint "failed to open file :(\n")
                (exit 1))))
        (file-close file)
        (let A = (new-alloc))
        (let p = (alloc (ref A)))
        (set (deref p) = 0)))

