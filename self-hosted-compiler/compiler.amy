//
// ==================================================================================================
// STANDARD LIBRARY STUFFS
// ==================================================================================================
//

// Loops while a condition is true.
(defmacro
    while condy
        stat
    &key else
    (loop
        (cond
            (condy stat)
            (:else (break else)))))

// Performs a short circuiting logical and.
(defmacro
    and x y
    (cond
        (x y)
        (:else 0)))

// Performs a short circuiting logical or.
(defmacro
    or x y
    (cond
        (x 1)
        (:else y)))

// Performs a logical not
(defmacro
    not x
    (cond
        (x 0)
        (:else 1)))

// Prints out a string onto stdout.
(defun print (str (@ mut u8))
    (seqn
        (syscall 1 1 (cast str.ptr) str.len 0 0 0)))

// Helper function for printing out an integer
(defun print-int-helper (i u64) (printer (fn ((@ mut u8))))
    (seqn
        (cond
            ((== i 0) (printer "0"))
            (:else (seqn
                (let p = (alloca 20))
                (let start = 19)
                (while (!= i 0) (seqn
                    (let c = (+ '0' (cast (% i 10))))
                    (set start = (- start 1))
                    (set (get p start) = c)
                    (set i = (/ i 10))))
                (printer (subslice p start (- p.len 1))))))))

// Prints out a number onto stdout.
(defun print-int (i u64)
    (print-int-helper i print))

// Prints out a number onto stderr.
(defun eprint-int (i u64)
    (print-int-helper i eprint))

// Prints out a string onto stderr.
(defun eprint (str (@ mut u8))
    (seqn
        (syscall 1 2 (cast str.ptr) str.len 0 0 0)))

// Exits the program
(defun exit (code i32)
    (seqn
        (syscall 60 (cast code) 0 0 0 0 0)))

// Creates a subslice from a given slice and range.
(defun subslice (s (@ mut 'a)) (start u64) (end u64) : (@ mut 'a)
    (slice (- end start) (ptr-add s.ptr start)))

// Defines a file (wrapper around a file descriptor).
(defstruct File
    (descriptor i32))

(defun file-is-valid (file File) : u1
    (> file.descriptor 0))

(defmacro FILE_OPEN_FLAG_READ_ONLY 0)

// Opens a file.
(defun file-open (path (@ mut u8)) (flags u64) : File
    (seq
        (let null-term = (alloca (+ path.len 1)))
        (let i = 0)
        (while (< i path.len)
            (seqn
                (set (get null-term i) = (get path i))
                (set i = (+ i 1))))
        (set (get null-term i) = '\0')
        (inst File
            (descriptor
                (cast (syscall 2 (cast null-term.ptr) flags 0 0 0 0))))))

// Reads a file into a vec of u8s.
(defun file-read-all (file File) (A (* mut Allocator)) : (Vec u8) (seq
    (let vec = (ref (new-vec A)))
    (let slice = (alloca 64))
    (while (let len = (syscall 0 (cast file.descriptor) (cast slice.ptr) slice.len 0 0 0)) (seqn
        (let i = 0)
        (while (< i len) (seqn
            (vec-push vec (get slice i))
            (set i = (+ i 1))))))
    (deref vec)))

// Closes a previously opened file.
(defun file-close (file File)
    (seqn
        (syscall 3 (cast file.descriptor) 0 0 0 0 0)))

// Maps memory for the program.
(defun mmap (len u64) : (* mut 'a)
    (cast (syscall 9 0 len 3 34 (- 0 1) 0)))

// Unmaps memory previously mapped by mmap.
(defun munmap (addr (* mut 'a)) (len u64)
    (seqn
        (syscall 11 (cast addr) len 0 0 0 0)))

// Creates a null constant.
(defun null : (* mut 'a)
    (cast (: u64 0)))

// Defines a free bucket linked list node for the memory allocator.
(defstruct FreeBucket
    (next (* mut FreeBucket)))

// Defines an allocator.
(defstruct Allocator
    (free16    (* mut FreeBucket))
    (free64    (* mut FreeBucket))
    (free256   (* mut FreeBucket))
    (free1024  (* mut FreeBucket))
    (free4096  (* mut FreeBucket))
    (free16384 (* mut FreeBucket))
    (free65536 (* mut FreeBucket)))

// Helper function for allocation to create size buckets.
(defun create-buckets (bucket-size u64) : (* mut FreeBucket)
    (seq
        (let p = (: (* mut u8) (mmap 65536)))
        (let i = (- bucket-size (sizeof FreeBucket)))
        (let q = (cast (ptr-add p i)))
        (while (< i 65536) (seqn
            (let q = (: (* mut FreeBucket) (cast (ptr-add p i))))
            (set i = (+ i bucket-size))
            (cond
                ((< i 65536) (seqn
                    (set (deref q).next = (cast (ptr-add p i)))))
                (:else (seqn
                    (set (deref q).next = (null)))))))
        q))

// Helper function for allocation.
(defun alloc-helper (A (* mut Allocator)) (size u64) : (* mut 'a)
    (cond
        ((== size 0) (null))
        ((<= size 8) (seq
            (cond
                ((== (deref A).free16 (null)) (seqn
                    (set (deref A).free16 = (create-buckets 16)))))
            (let ptr = (deref A).free16)
            (set (deref A).free16 = (deref ptr).next)
            (cast (- (: u64 (cast ptr)) 8))))

        ((<= size 56) (seq
            (cond
                ((== (deref A).free64 (null)) (seqn
                    (set (deref A).free64 = (create-buckets 64)))))
            (let ptr = (deref A).free64)
            (set (deref A).free64 = (deref ptr).next)
            (cast (- (: u64 (cast ptr)) 56))))

        ((<= size 248) (seq
            (cond
                ((== (deref A).free256 (null)) (seqn
                    (set (deref A).free256 = (create-buckets 256)))))
            (let ptr = (deref A).free256)
            (set (deref A).free256 = (deref ptr).next)
            (cast (- (: u64 (cast ptr)) 248))))

        ((<= size 1016) (seq
            (cond
                ((== (deref A).free1024 (null)) (seqn
                    (set (deref A).free1024 = (create-buckets 1024)))))
            (let ptr = (deref A).free1024)
            (set (deref A).free1024 = (deref ptr).next)
            (cast (- (: u64 (cast ptr)) 1016))))

        ((<= size 4088) (seq
            (cond
                ((== (deref A).free4096 (null)) (seqn
                    (set (deref A).free4096 = (create-buckets 4096)))))
            (let ptr = (deref A).free4096)
            (set (deref A).free4096 = (deref ptr).next)
            (cast (- (: u64 (cast ptr)) 4088))))

        ((<= size 16376) (seq
            (cond
                ((== (deref A).free16384 (null)) (seqn
                    (set (deref A).free16384 = (create-buckets 16384)))))
            (let ptr = (deref A).free16384)
            (set (deref A).free16384 = (deref ptr).next)
            (cast (- (: u64 (cast ptr)) 16376))))

        ((<= size 65528) (seq
            (cond
                ((== (deref A).free65536 (null)) (seqn
                    (set (deref A).free65536 = (create-buckets 65536)))))
            (let ptr = (deref A).free65536)
            (set (deref A).free65536 = (deref ptr).next)
            (cast (- (: u64 (cast ptr)) 65528))))

        (:else
            (mmap size))))

// Helper function for deallocation.
(defun dealloc-helper (A (* mut Allocator)) (ptr (* mut 'a)) (size u64)
    (cond
        ((or (== size 0) (== ptr (null))) ())
        ((<= size 8) (seqn
            (let p = (ptr-add (: (* mut u8) (cast ptr)) 8))
            (let bucket = (: (* mut FreeBucket) (cast p)))
            (set (deref bucket).next = (deref A).free16)
            (set (deref A).free16 = bucket)))

        ((<= size 56) (seqn
            (let p = (ptr-add (: (* mut u8) (cast ptr)) 56))
            (let bucket = (: (* mut FreeBucket) (cast p)))
            (set (deref bucket).next = (deref A).free64)
            (set (deref A).free64 = bucket)))

        ((<= size 248) (seqn
            (let p = (ptr-add (: (* mut u8) (cast ptr)) 248))
            (let bucket = (: (* mut FreeBucket) (cast p)))
            (set (deref bucket).next = (deref A).free256)
            (set (deref A).free256 = bucket)))

        ((<= size 1016) (seqn
            (let p = (ptr-add (: (* mut u8) (cast ptr)) 1016))
            (let bucket = (: (* mut FreeBucket) (cast p)))
            (set (deref bucket).next = (deref A).free1024)
            (set (deref A).free1024 = bucket)))

        ((<= size 4088) (seqn
            (let p = (ptr-add (: (* mut u8) (cast ptr)) 4088))
            (let bucket = (: (* mut FreeBucket) (cast p)))
            (set (deref bucket).next = (deref A).free4096)
            (set (deref A).free4096 = bucket)))

        ((<= size 16376) (seqn
            (let p = (ptr-add (: (* mut u8) (cast ptr)) 16376))
            (let bucket = (: (* mut FreeBucket) (cast p)))
            (set (deref bucket).next = (deref A).free16384)
            (set (deref A).free16384 = bucket)))

        ((<= size 65528) (seqn
            (let p = (ptr-add (: (* mut u8) (cast ptr)) 65528))
            (let bucket = (: (* mut FreeBucket) (cast p)))
            (set (deref bucket).next = (deref A).free65536)
            (set (deref A).free65536 = bucket)))

        (:else
            (munmap ptr size))))

// Allocates a pointer to some data.
(defun alloc (A (* mut Allocator)) : (* mut 'a)
    (alloc-helper A (sizeof 'a)))

// Deallocates a pointer.
(defun dealloc (A (* mut Allocator)) (ptr (* mut 'a))
    (dealloc-helper A ptr (sizeof 'a)))

// Allocates an array of data.
(defun alloc-array (A (* mut Allocator)) (len u64) : (@ mut 'a)
    (slice len (alloc-helper A (* len (sizeof 'a)))))

// Deallocates an array of data.
(defun dealloc-array (A (* mut Allocator)) (s (@ mut 'a)) 
    (dealloc-helper A s.ptr (* s.len (sizeof 'a))))

// Creates a new empty allocator.
(defun new-alloc : Allocator
    (inst Allocator
        (free16    (null))
        (free64    (null))
        (free256   (null))
        (free1024  (null))
        (free4096  (null))
        (free16384 (null))
        (free65536 (null))))

// Defines a vector (ie a list).
(defstruct Vec
    (vals (@ mut 'a))
    (len u64)
    (A (* mut Allocator)))

// Creates a new empty vector.
(defun new-vec (A (* mut Allocator)) : (Vec 'a)
    (inst Vec
        (vals (slice 0 (null)))
        (len 0)
        (A A)))

// Gets the ith element of a vector.
(defun vec-get (v (* mut (Vec 'a))) (i u64) : (* mut 'a)
    (cond
        ((< i (deref v).len) (ptr-add (deref v).vals.ptr i))
        (:else (null))))

// Pushes a value onto a vector.
(defun vec-push (vec (* mut (Vec 'a))) (v 'a) (seqn
    (cond
        ((<= (deref vec).vals.cap (deref vec).len) (seqn
            (let new-cap = (cond
                ((== (deref vec).vals.cap 0) 8)
                (:else (* (deref vec).vals.cap 2))))
            (let new-vals = (alloc-array (deref vec).A new-cap))
            (let i = 0)
            (while (< i (deref vec).len) (seqn
                (set (get new-vals i) = (get (deref vec).vals i))
                (set i = (+ i 1))))
            (dealloc-array (deref vec).A (deref vec).vals)
            (set (deref vec).vals = new-vals))))
    (set (get (deref vec).vals (deref vec).len) = v)
    (set (deref vec).len = (+ (deref vec).len 1))))

// Pops a value from a vector
// TODO: this leaks memory
(defun vec-pop (vec (* mut (Vec 'a))) (seqn
    (cond
        ((> (deref vec).len 0) (seqn
            (set (deref vec).len = (- (deref vec).len 1)))))))

// Creates a slice from a vector.
(defun vec-slice (vec (* mut (Vec 'a))) : (@ mut 'a)
    (subslice (deref vec).vals 0 (deref vec).len))

(defun vec-find (vec (* mut (Vec 'a))) (pred (fn ((* mut 'a) 'b) : u1)) (data 'b) : (* mut 'a) (seq
    (let i = 0)
    (while (< i (deref vec).len) (seqn
        (let item = (vec-get vec i))
        (cond
            ((pred item data)
                (break item)))
        (set i = (+ i 1)))
    :else (null))))

// Empty deallocator
(defun empty-dealloc (v (* mut 'a)) ())

// Drops a vector
(defun vec-drop (vec (* mut (Vec 'a))) (callback (fn ((* mut 'a)))) (seqn
    (let i = 0)
    (while (< i (deref vec).len) (seqn
        (callback (ptr-add (deref vec).vals.ptr i))
        (set i = (+ i 1))))
    (dealloc-array (deref vec).A (deref vec).vals)))

// Checks if a string slice contains a character.
(defun str-contains (str (@ mut u8)) (c u8) : u1 (seq
    (let i = 0)
    (while (< i str.len) (seqn
        (cond
            ((== c (get str i))
                (break true)))
        (set i = (+ i 1)))
    :else false)))

(defun str-equals (a (@ mut u8)) (b (@ mut u8)) : u1
    (cond
        ((!= a.len b.len) false)
        (:else (seq
            (let i = 0)
            (while (< i a.len) (seqn
                (cond
                    ((!= (get a i) (get b i))
                        (break false)))
                (set i = (+ i 1)))
            :else true)))))

(defun get-argv (argv (* mut (* mut u8))) (i u64) : (@ mut u8) (seq
    (let j = 0)
    (while (<= j i) (seqn
        (cond
            ((== (deref (ptr-add argv j)) (null))
                (break (slice 0 (null)))))
        (set j = (+ j 1)))
    :else (seq
        (let p = (deref (ptr-add argv i)))
        (let len = 0)
        (while (deref (ptr-add p len)) (seqn
            (set len = (+ len 1))))
        (slice len p)))))

(defstruct Pair
    (a 'a)
    (b 'b))

(defun key-find (pair (* mut (Pair (@ mut u8) 'a))) (str (@ mut u8)) : u1
    (str-equals (deref pair).a str))



//
// ==================================================================================================
// LEXING
// ==================================================================================================
//

// Defines a location in source code.
(defstruct Location
    (start u64)
    (end u64))

// Defines a token.
(defstruct Token
    (loc Location)
    (type u64)
    (value (@ mut u8)))

(defmacro TOKEN_TYPE_EOF     0)
(defmacro TOKEN_TYPE_INVALID 1)
(defmacro TOKEN_TYPE_LPAREN  2)
(defmacro TOKEN_TYPE_RPAREN  3)
(defmacro TOKEN_TYPE_INT     4)
(defmacro TOKEN_TYPE_SYMBOL  5)
(defmacro TOKEN_TYPE_KEY     6)
(defmacro TOKEN_TYPE_DOT     7)
(defmacro TOKEN_TYPE_QUOTE   8)
(defmacro TOKEN_TYPE_STRING  9)
(defmacro TOKEN_TYPE_CHAR   10)

// Defines a lexer.
(defstruct Lexer
    (str (@ mut u8))
    (pos u64)
    (tokens (Vec Token))
    (token-pos u64))

// Creates a new lexer.
(defun new-lexer (A (* mut Allocator)) (str (@ mut u8)) : Lexer
    (inst Lexer
        (str str)
        (pos 0)
        (tokens (new-vec A))
        (token-pos 0)))

// Lexes a string.
(defun lex-next (lexer (* mut Lexer)) : Token
    (cond
        ((< (deref lexer).token-pos (deref lexer).tokens.len) (seq
            (let v = (vec-get (ref (deref lexer).tokens) (deref lexer).token-pos))
            (set (deref lexer).token-pos = (+ (deref lexer).token-pos 1))
            (deref v)))
        (:else (seq
            (let i = (deref lexer).pos)
            (let state = 0)
            (let comment-mode = 0)
            (let type = (TOKEN_TYPE_INVALID))
            (while (< i (deref lexer).str.len) (seqn
                (let c = (get (deref lexer).str i))
                (set i = (+ i 1))
                (let next = (cond
                    ((< i (deref lexer).str.len) (get (deref lexer).str i))
                    (:else 0)))
                (cond
                    // Line comments
                    ((and (== comment-mode 1) (== c '\n')) (seqn
                        (set comment-mode = 0)
                        (set (deref lexer).pos = i)))
                    ((== comment-mode 1) ())

                    // Block comments
                    ((and (== comment-mode 2) (and (== c '*') (== next '/'))) (seqn
                        (set comment-mode = 0)
                        (set i = (+ i 1))
                        (set (deref lexer).pos = i)))
                    ((== comment-mode 2) ())

                    // Initial state
                    ((== state 0) (cond
                        // Line comments
                        ((and (== c '/') (== next '/')) (seqn
                            (set comment-mode = 1)))

                        // Block comments
                        ((and (== c '/') (== next '*')) (seqn
                            (set comment-mode = 2)))

                        // Whitespace
                        ((str-contains " \n\t\r" c) (seqn
                            (set (deref lexer).pos = i)))

                        // Left parenthesis
                        ((== c 40) (seqn
                            (set type = (TOKEN_TYPE_LPAREN))
                            (break)))

                        // Right parenthesis
                        ((== c 41) (seqn
                            (set type = (TOKEN_TYPE_RPAREN))
                            (break)))

                        // Dot
                        ((== c '.') (seqn
                            (set type = (TOKEN_TYPE_DOT))
                            (break)))

                        // Quote
                        ((== c '\'') (seqn
                            (set type = (TOKEN_TYPE_CHAR))
                            (set state = 1)))

                        // Integers
                        ((and (<= '0' c) (<= c '9')) (seqn
                            (set type = (TOKEN_TYPE_INT))
                            (set state = 1)))

                        // Colon symbol
                        ((and (== c ':') (not (str-contains "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_=+|/?~!@$%^&*<>" next))) (seqn
                            (set type = (TOKEN_TYPE_SYMBOL))
                            (break)))

                        // Symbols
                        ((str-contains "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_=+|/?~!@$%^&*<>" c) (seqn
                            (set type = (TOKEN_TYPE_SYMBOL))
                            (set state = 1)))

                        // Keys
                        ((== c ':') (seqn
                            (set type = (TOKEN_TYPE_KEY))
                            (set state = 1)))

                        ((== c '"') (seqn
                            (set type = (TOKEN_TYPE_STRING))
                            (set state = 1)))

                        // Everything else is invalid
                        (:else (break))))

                    // Integers
                    ((== type (TOKEN_TYPE_INT))
                        (cond
                            ((or (> '0' c) (> c '9')) (seqn
                                (set i = (- i 1))
                                (break)))))

                    // Symbols
                    ((== type (TOKEN_TYPE_SYMBOL))
                        (cond
                            ((or (not (str-contains "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_=+|/?~!@$%^&*<>" c)) (and (== c '/') (== next '*'))) (seqn
                                (set i = (- i 1))
                                (break)))))

                    // Keys
                    ((== type (TOKEN_TYPE_KEY))
                        (cond
                            ((or (not (str-contains "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_=+|/?~!@$%^&*<>" c)) (and (== c '/') (== next '*'))) (seqn
                                (set i = (- i 1))
                                (break)))))

                    // String unescaped character
                    ((and (== type (TOKEN_TYPE_STRING)) (== state 1))
                        (cond
                            ((== c '\\') (seqn
                                (set state = 2)))
                            ((== c '"')
                                (break))))

                    // String escaped character
                    ((and (== type (TOKEN_TYPE_STRING)) (== state 2)) (seqn
                        (set state = 1)))

                    // Beginning of a character
                    ((and (== type (TOKEN_TYPE_CHAR)) (== state 1))
                        (cond
                            ((== c '\\') (seqn
                                (set state = 2)))
                            ((!= next '\'') (seqn
                                (set i = (- i 1))
                                (set type = (TOKEN_TYPE_QUOTE))
                                (break)))
                            (:else (seqn
                                (set state = 3)))))

                    // Escaped character
                    ((and (== type (TOKEN_TYPE_CHAR)) (== state 2))
                        (cond
                            ((str-contains "nrt0\\'\"" c) (seqn
                                (set state = 3)))
                            (:else (seqn
                                (set type = (TOKEN_TYPE_INVALID))
                                (break)))))

                    // End of character
                    ((and (== type (TOKEN_TYPE_CHAR)) (== state 3))
                        (cond
                            ((== c '\'')
                                (break))
                            (:else (seqn
                                (set type = (TOKEN_TYPE_INVALID))
                                (break))))))))

            (let start = (deref lexer).pos)
            (cond ((== start i) (seqn
                (set type = (TOKEN_TYPE_EOF)))))
            (set (deref lexer).pos = i)
            (let token = (inst Token
                (loc (inst Location
                    (start start)
                    (end i)))
                (type type)
                (value (subslice (deref lexer).str start i))))
            (let token-vec = (ref (deref lexer).tokens))
            (vec-push token-vec token)
            (set (deref lexer).tokens = (deref token-vec))
            (set (deref lexer).token-pos = (+ (deref lexer).token-pos 1))
            token))))

// Peeks into the lexer and returns the next token without consuming it.
(defun lex-peek (lexer (* mut Lexer)) : Token (seq
    (let token = (lex-next lexer))
    (set (deref lexer).token-pos = (- (deref lexer).token-pos 1))
    token))

// Drops a lexer.
(defun lexer-drop (lexer (* mut Lexer))
    (vec-drop (ref (deref lexer).tokens) empty-dealloc))

// Prints out a token.
(defstruct LexerResult
    (token Token)
    (fail ParseFailure)
    (success u1))

// Expects a type of token and fails if the token is not next.
(defun lexer-expect (lexer (* mut Lexer)) (type u64) : LexerResult
    (cond
        ((== type (lex-peek lexer).type)
            (inst LexerResult
                (token (lex-next lexer))
                (fail (inst ParseFailure
                    (loc (inst Location
                        (start 0)
                        (end 0)))
                    (expected 0)
                    (received 0)))
                (success true)))
        (:else
            (inst LexerResult
                (token (inst Token
                    (loc (inst Location
                        (start 0)
                        (end 0)))
                    (type 0)
                    (value "")))
                (fail (inst ParseFailure
                    (loc (lex-peek lexer).loc)
                    (expected type)
                    (received (lex-peek lexer).type)))
                (success false)))))



//
// ==================================================================================================
// PARSER
// ==================================================================================================
//

(defmacro AST_NODE_TYPE_INVALID  0)
(defmacro AST_NODE_TYPE_ROOT     1)
(defmacro AST_NODE_TYPE_SEXPR    2)
(defmacro AST_NODE_TYPE_INT      3)
(defmacro AST_NODE_TYPE_SYMBOL   4)
(defmacro AST_NODE_TYPE_KEY      5)
(defmacro AST_NODE_TYPE_ATTR     6)
(defmacro AST_NODE_TYPE_QUOTE    7)
(defmacro AST_NODE_TYPE_STRING   8)
(defmacro AST_NODE_TYPE_CHAR     9)

(defmacro ERROR_TYPE_VALUE (- 0 1))

(defstruct Ast
    (type u64)
    (loc Location)
    (typed Type)
    (value (@ mut u8))
    (children (Vec Ast)))

(defun ast-clone (ast Ast) : Ast
    (seq
        (let children = (ref (new-vec ast.children.A)))
        (let i = 0)
        (while (< i ast.children.len) (seqn
            (vec-push children (ast-clone (deref (vec-get (ref ast.children) i))))
            (set i = (+ i 1))))
        (inst Ast
            (type ast.type)
            (loc ast.loc)
            (typed (empty-type ast.children.A))
            (value ast.value)
            (children (deref children)))))

(defun ast-drop (ast (* mut Ast))
    // TODO: dropping types
    (vec-drop (ref (deref ast).children) ast-drop))

(defun print-ast-helper (ast (* mut Ast)) (level u64) (seqn
    (let i = 0)
    (while (< i level) (seqn
        (print "    ")
        (set i = (+ i 1))))
    (print-int (deref ast).loc.start)
    (print "..")
    (print-int (deref ast).loc.end)
    (print " ")
    (cond
        ((== (deref ast).type (AST_NODE_TYPE_INVALID))
            (print "INVALID"))
        ((== (deref ast).type (AST_NODE_TYPE_ROOT))
            (print "ROOT"))
        ((== (deref ast).type (AST_NODE_TYPE_SEXPR))
            (print "SEXPR"))
        ((== (deref ast).type (AST_NODE_TYPE_INT))
            (print "INT"))
        ((== (deref ast).type (AST_NODE_TYPE_SYMBOL))
            (print "SYMBOL"))
        ((== (deref ast).type (AST_NODE_TYPE_KEY))
            (print "KEY"))
        ((== (deref ast).type (AST_NODE_TYPE_ATTR))
            (print "ATTRIBUTE"))
        ((== (deref ast).type (AST_NODE_TYPE_QUOTE))
            (print "QUOTE"))
        ((== (deref ast).type (AST_NODE_TYPE_STRING))
            (print "STRING"))
        ((== (deref ast).type (AST_NODE_TYPE_CHAR))
            (print "CHAR"))
        (:else
            (print "UNKNOWN")))
    (print " ")
    (print (deref ast).value)
    (print " : ")
    (print-type (ref (deref ast).typed))
    (print "\n")
    (let i = 0)
    (while (!= (let child = (vec-get (ref (deref ast).children) i)) (null)) (seqn
        (print-ast-helper child (+ level 1))
        (set i = (+ i 1))))))

(defun print-ast (ast (* mut Ast))
    (print-ast-helper ast 0))

(defstruct LineColumn
    (line-start u64)
    (col-start u64)
    (line-end u64)
    (col-end u64))

(defun loc-to-line-col (contents (@ mut u8)) (loc Location) : LineColumn (seq
    (let i = 0)
    (let line-start = 1)
    (let col-start = 0)
    (while (< i loc.start) (seqn
        (cond
            ((== (get contents i) '\n') (seqn
                (set line-start = (+ line-start 1))
                (set col-start = 0)))
            (:else (seqn
                (set col-start = (+ col-start 1)))))
        (set i = (+ i 1))))
    (let line-end = line-start)
    (let col-end = col-start)
    (while (< i loc.end) (seqn
        (cond
            ((== (get contents i) '\n') (seqn
                (set line-end = (+ line-end 1))
                (set col-end = 0)))
            (:else (seqn
                (set col-end = (+ col-end 1)))))
        (set i = (+ i 1))))
    (inst LineColumn
        (line-start line-start)
        (col-start col-start)
        (line-end line-end)
        (col-end col-end))))

(defun print-parse-error-helper (type u64)
    (cond
        ((== type (ERROR_TYPE_VALUE))
            (eprint "VALUE"))
        ((== type (TOKEN_TYPE_EOF))
            (eprint "EOF"))
        ((== type (TOKEN_TYPE_INVALID))
            (eprint "INVALID"))
        ((== type (TOKEN_TYPE_LPAREN))
            (eprint "LPAREN"))
        ((== type (TOKEN_TYPE_RPAREN))
            (eprint "RPAREN"))
        ((== type (TOKEN_TYPE_INT))
            (eprint "INT"))
        ((== type (TOKEN_TYPE_SYMBOL))
            (eprint "SYMBOL"))
        ((== type (TOKEN_TYPE_KEY))
            (eprint "KEY"))
        ((== type (TOKEN_TYPE_DOT))
            (eprint "DOT"))
        ((== type (TOKEN_TYPE_QUOTE))
            (eprint "QUOTE"))
        ((== type (TOKEN_TYPE_STRING))
            (eprint "STRING"))
        ((== type (TOKEN_TYPE_CHAR))
            (eprint "CHAR"))
        (:else
            (eprint "UNKNOWN"))))

(defun print-parse-error (contents (@ mut u8)) (fail (* mut ParseFailure)) (seqn
    (eprint "error: expected ")
    (print-parse-error-helper (deref fail).expected)
    (eprint ", got ")
    (print-parse-error-helper (deref fail).received)
    (let line-col = (loc-to-line-col contents (deref fail).loc))
    (eprint " (")
    (eprint-int line-col.line-start)
    (eprint ":")
    (eprint-int line-col.col-start)
    (eprint "..")
    (eprint-int line-col.line-end)
    (eprint ":")
    (eprint-int line-col.col-end)
    (eprint ")\n")))

(defstruct ParseFailure
    (loc Location)
    (expected u64)
    (received u64))

(defstruct ParseResult
    (ast Ast)
    (fail ParseFailure)
    (success u1))

(defun parse-fail (fail ParseFailure) : ParseResult
    (inst ParseResult
        (ast (inst Ast
            (type 0)
            (loc (inst Location
                (start 0)
                (end 0)))
            (typed (empty-type (null)))
            (value (slice 0 (null)))
            (children (new-vec (null)))))
        (fail fail)
        (success false)))

(defun parse-success (ast Ast) : ParseResult
    (inst ParseResult
        (ast ast)
        (fail (inst ParseFailure
            (loc (inst Location
                (start 0)
                (end 0)))
            (expected 0)
            (received 0)))
        (success true)))

(defmacro
    pguard var = value
        stats
    &key else
    (seq
        (let var = value)
        (cond
            (var.success (seq
                (let var = var.ast)
                stats))
            (:else (seq
                else
                var)))))

(defmacro
    lguard var = value
        stats
    &key else
    (seq
        (let var = value)
        (cond
            (var.success (seq
                (let var = var.token)
                stats))
            (:else (seq
                else
                (parse-fail var.fail))))))

(defun parse-value (lexer (* mut Lexer)) : ParseResult
    (seq
        (let token = (lex-peek lexer))
        (cond
            ((== token.type (TOKEN_TYPE_LPAREN))
                (parse-sexpr lexer))

            ((== token.type (TOKEN_TYPE_SYMBOL)) (seq
                (lex-next lexer)
                (parse-success (inst Ast
                    (type (AST_NODE_TYPE_SYMBOL))
                    (loc token.loc)
                    (typed (empty-type (deref lexer).tokens.A))
                    (value token.value)
                    (children (new-vec (deref lexer).tokens.A))))))

            ((== token.type (TOKEN_TYPE_INT)) (seq
                (lex-next lexer)
                (parse-success (inst Ast
                    (type (AST_NODE_TYPE_INT))
                    (loc token.loc)
                    (typed (empty-type (deref lexer).tokens.A))
                    (value token.value)
                    (children (new-vec (deref lexer).tokens.A))))))

            ((== token.type (TOKEN_TYPE_KEY)) (seq
                (lex-next lexer)
                (parse-success (inst Ast
                    (type (AST_NODE_TYPE_KEY))
                    (loc token.loc)
                    (typed (empty-type (deref lexer).tokens.A))
                    (value token.value)
                    (children (new-vec (deref lexer).tokens.A))))))

            ((== token.type (TOKEN_TYPE_QUOTE)) (seq
                (lex-next lexer)
                (pguard quoted = (parse-value lexer) (seq
                    (let children = (ref (new-vec (deref lexer).tokens.A)))
                    (vec-push children quoted)
                    (parse-success (inst Ast
                        (type (AST_NODE_TYPE_QUOTE))
                        (loc token.loc)
                        (typed (empty-type (deref lexer).tokens.A))
                        (value "")
                        (children (deref children))))))))

            ((== token.type (TOKEN_TYPE_STRING)) (seq
                (lex-next lexer)
                (parse-success (inst Ast
                    (type (AST_NODE_TYPE_STRING))
                    (loc token.loc)
                    (typed (empty-type (deref lexer).tokens.A))
                    (value token.value)
                    (children (new-vec (deref lexer).tokens.A))))))

            ((== token.type (TOKEN_TYPE_CHAR)) (seq
                (lex-next lexer)
                (parse-success (inst Ast
                    (type (AST_NODE_TYPE_CHAR))
                    (loc token.loc)
                    (typed (empty-type (deref lexer).tokens.A))
                    (value token.value)
                    (children (new-vec (deref lexer).tokens.A))))))

            (:else (parse-fail (inst ParseFailure
                (loc token.loc)
                (expected (ERROR_TYPE_VALUE))
                (received token.type)))))))

(defun parse-attr-item (lexer (* mut Lexer)) : ParseResult (seq
    (let token = (lex-peek lexer))
    (cond
        ((== token.type (TOKEN_TYPE_SYMBOL)) (seq
            (lex-next lexer)
            (parse-success (inst Ast
                (type (AST_NODE_TYPE_SYMBOL))
                (loc token.loc)
                (typed (empty-type (deref lexer).tokens.A))
                (value token.value)
                (children (new-vec (deref lexer).tokens.A))))))

        ((== token.type (TOKEN_TYPE_LPAREN))
            (parse-sexpr lexer))

        (:else (parse-fail (inst ParseFailure
                (loc token.loc)
                (expected (ERROR_TYPE_VALUE))
                (received token.type)))))))

(defun parse-attribute (lexer (* mut Lexer)) : ParseResult
    (pguard top = (parse-value lexer)
        (seq
            (let attrs = (ref (new-vec (deref lexer).tokens.A)))
            (vec-push attrs top)
            (while (== (lex-peek lexer).type (TOKEN_TYPE_DOT))
                (seqn
                    (lex-next lexer)
                    (let attr = (parse-attr-item lexer))
                    (cond
                        (attr.success
                            (vec-push attrs attr.ast))
                        (:else (seqn
                            (vec-drop attrs ast-drop)
                            (break attr)))))
            :else (cond
                ((> (deref attrs).len 1)
                    (parse-success (inst Ast
                        (type (AST_NODE_TYPE_ATTR))
                        (loc (inst Location
                            (start top.loc.start)
                            (end (deref (vec-get attrs (- (deref attrs).len 1))).loc.end)))
                        (typed (empty-type (deref lexer).tokens.A))
                        (value "")
                        (children (deref attrs)))))
                (:else (seq
                    (vec-drop attrs empty-dealloc)
                    (parse-success top))))))))

(defun parse-sexpr (lexer (* mut Lexer)) : ParseResult
    (lguard left = (lexer-expect lexer (TOKEN_TYPE_LPAREN)) (seq
        (let v = (ref (new-vec (deref lexer).tokens.A)))
        (while (let var = (parse-attribute lexer)).success (seqn
            (vec-push v var.ast)))
        (lguard right = (lexer-expect lexer (TOKEN_TYPE_RPAREN))
            (parse-success (inst Ast
                (type (AST_NODE_TYPE_SEXPR))
                (loc (inst Location
                    (start left.loc.start)
                    (end right.loc.end)))
                (typed (empty-type (deref lexer).tokens.A))
                (value "")
                (children (deref v))))
        :else (vec-drop v ast-drop)))))

(defun parse (lexer (* mut Lexer)) : ParseResult (seq
    (let asts = (ref (new-vec (deref lexer).tokens.A)))
    (let end = 0)
    (while (!= (lex-peek lexer).type (TOKEN_TYPE_EOF)) (seqn
        (let sexpr = (parse-sexpr lexer))
        (cond
            ((not sexpr.success) (seqn
                (vec-drop asts ast-drop)
                (break sexpr))))
        (set end = sexpr.ast.loc.end)
        (vec-push asts sexpr.ast))
    :else (parse-success
        (inst Ast
            (type (AST_NODE_TYPE_ROOT))
            (loc (inst Location
                (start 0)
                (end end)))
            (typed (empty-type (deref lexer).tokens.A))
            (value (slice 0 (null)))
            (children (deref asts)))))))



//
// ==================================================================================================
// MACROS
// ==================================================================================================
//

(defmacro MACRO_ARG_TYPE_ORDERED  0)
(defmacro MACRO_ARG_TYPE_ATOM     1)
(defmacro MACRO_ARG_TYPE_KEY      2)
(defmacro MACRO_ARG_TYPE_REST     3)

(defstruct MacroArg
    (name (@ mut u8))
    (type u64)
    (value Ast))

(defstruct Macro
    (args (Vec MacroArg))
    (body Ast))

(defun extract-macros (map (* mut (Vec (Pair (@ mut u8) Macro)))) (root (* mut Ast)) (seqn
    (let i = 0)
    (while (< i (deref root).children.len) (seqn
        (let ast = (vec-get (ref (deref root).children) i))
        (let contents = (ref (deref ast).children))
        (cond
            ((and (>= (deref contents).len 2) (== (deref ast).type (AST_NODE_TYPE_SEXPR))) (seqn
                (let name = (vec-get contents 0))
                (cond
                    ((and (== (deref name).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref name).value "defmacro"))
                        (seqn
                            (let name = (vec-get contents 1))
                            (cond
                                ((== (deref name).type (AST_NODE_TYPE_SYMBOL)) (seqn
                                    (let name = (deref name).value)
                                    (let args = (ref (new-vec (deref contents).A)))
                                    (let type = (MACRO_ARG_TYPE_ORDERED))
                                    (let i = 2)
                                    (while (< i (- (deref contents).len 1)) (seqn
                                        (let arg = (vec-get contents i))
                                        (cond
                                            ((and (== (deref arg).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref arg).value "&key")) (seqn
                                                (set type = (MACRO_ARG_TYPE_KEY))))
                                            ((and (== (deref arg).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref arg).value "&rest")) (seqn
                                                (set type = (MACRO_ARG_TYPE_REST))))

                                            ((== (deref arg).type (AST_NODE_TYPE_SYMBOL)) (seqn
                                                (vec-push args (inst MacroArg
                                                    (name (deref arg).value)
                                                    (type type)
                                                    (value (inst Ast
                                                        (type 0)
                                                        (loc (inst Location
                                                            (start 0)
                                                            (end 0)))
                                                        (typed (empty-type (deref args).A))
                                                        (value "")
                                                        (children (new-vec (deref args).A))))))))

                                            ((and (== (deref arg).type (AST_NODE_TYPE_SEXPR)) (== (deref arg).children.len 2)) (seqn
                                                (let ast = (deref (vec-get (ref (deref arg).children) 1)))
                                                (let name = (deref (vec-get (ref (deref arg).children) 0)))
                                                (cond
                                                    ((== name.type (AST_NODE_TYPE_SYMBOL))
                                                        (vec-push args (inst MacroArg
                                                            (name name.value)
                                                            (type type)
                                                            (value ast)))))))

                                            ((and (== (deref arg).type (AST_NODE_TYPE_QUOTE)) (== (deref (vec-get (ref (deref arg).children) 0)).type (AST_NODE_TYPE_SYMBOL)))
                                                (vec-push args (inst MacroArg
                                                    (name (deref (vec-get (ref (deref arg).children) 0)).value)
                                                    (type (MACRO_ARG_TYPE_ATOM))
                                                    (value (inst Ast
                                                        (type 0)
                                                        (loc (inst Location
                                                            (start 0)
                                                            (end 0)))
                                                        (typed (empty-type (deref args).A))
                                                        (value "")
                                                        (children (new-vec (deref args).A))))))))

                                        (set i = (+ i 1))))

                                    (let ast = (cond
                                        ((> (deref contents).len 2)
                                            (deref (vec-get contents (- (deref contents).len 1))))
                                        (:else (inst Ast
                                            (type 0)
                                            (loc (inst Location
                                                (start 0)
                                                (end 0)))
                                            (typed (empty-type (deref args).A))
                                            (value "")
                                            (children (new-vec (deref args).A))))))
                                    (vec-push map (inst Pair
                                        (a name)
                                        (b (inst Macro
                                            (args (deref args))
                                            (body ast))))))))))))))
        (set i = (+ i 1))))))

(defun print-macros (map (* mut (Vec (Pair (@ mut u8) Macro)))) (seqn
    (let i = 0)
    (while (< i (deref map).len) (seqn
        (let macro = (deref (vec-get map i)))
        (print "Macro ")
        (print macro.a)
        (let macro = macro.b)
        (print ":\n    Args:\n")
        (let j = 0)
        (while (< j macro.args.len) (seqn
            (print "        ")
            (let arg = (deref (vec-get (ref macro.args) j)))
            (print arg.name)
            (print " ")
            (cond
                ((== arg.type (MACRO_ARG_TYPE_ORDERED))
                    (print "ORDERED"))
                ((== arg.type (MACRO_ARG_TYPE_ATOM))
                    (print "ATOM"))
                ((== arg.type (MACRO_ARG_TYPE_KEY))
                    (print "KEY"))
                ((== arg.type (MACRO_ARG_TYPE_REST))
                    (print "REST"))
                (:else
                    (print "UNKNOWN")))
            (print "\n")
            (print-ast-helper (ref arg.value) 3)
            (set j = (+ j 1))))
        (print "    Body:\n")
        (print-ast-helper (ref macro.body) 2)
        (set i = (+ i 1))))))

(defmacro CAPTURED_MACRO_ARG_NONE   0)
(defmacro CAPTURED_MACRO_ARG_SINGLE 1)
(defmacro CAPTURED_MACRO_ARG_REST   2)

(defstruct CapturedMacroArg
    (type u64)
    (start u64))

(defun macro-bind (args (@ mut Ast)) (macro (* mut Macro)) (arg-bindings (* mut (Vec (Pair (@ mut u8) CapturedMacroArg)))) : u1 (seq
    (let i = 0)
    (while (< i (deref macro).args.len) (seqn
        (let arg = (deref (vec-get (ref (deref macro).args) i)))
        (cond
            ((!= arg.type (MACRO_ARG_TYPE_ATOM))
                (vec-push arg-bindings (inst Pair
                    (a arg.name)
                    (b (inst CapturedMacroArg
                        (type (CAPTURED_MACRO_ARG_NONE))
                        (start 0)))))))
        (set i = (+ i 1))))

    (let ordered-arg = 0)
    (let last-key = "")
    (let i = 0)
    (while (< i args.len) (seqn
        (let arg = (get args i))
        (cond
            ((== arg.type (AST_NODE_TYPE_KEY))
                (cond
                    (last-key.len
                        (break false))
                    ((: u64 (cast (vec-find arg-bindings key-find (let key = (subslice arg.value 1 arg.value.len))))) (seqn
                        (set last-key = key)))
                    (:else
                        (break false))))
            ((> last-key.len 0) (seqn
                (let arg = (get args (- i 1)))
                (let binding = (vec-find arg-bindings key-find (let key = (subslice arg.value 1 arg.value.len))))
                (set (deref binding).b = (inst CapturedMacroArg
                    (type (CAPTURED_MACRO_ARG_SINGLE))
                    (start i)))
                (set last-key = "")))
            ((: u64 (cast (let arg = (vec-get (ref (deref macro).args) ordered-arg)))) (seqn
                (let arg = (deref arg))
                (cond
                    ((== arg.type (MACRO_ARG_TYPE_ORDERED)) (seqn
                        (let binding = (vec-find arg-bindings key-find arg.name))
                        (set (deref binding).b = (inst CapturedMacroArg
                            (type (CAPTURED_MACRO_ARG_SINGLE))
                            (start i)))))
                    ((== arg.type (MACRO_ARG_TYPE_ATOM)) (seqn
                        (let arg-actual = (get args i))
                        (cond
                            ((or (!= arg-actual.type (AST_NODE_TYPE_SYMBOL)) (not (str-equals arg-actual.value arg.name)))
                                (break false)))))
                    ((== arg.type (MACRO_ARG_TYPE_REST)) (seqn
                        (let j = (+ i 1))
                        (cond
                            ((while (< j args.len) (seqn
                                (let arg = (get args j))
                                (cond
                                    ((== arg.type (MACRO_ARG_TYPE_KEY))
                                        (break true)))
                                (set j = (+ j 1)))
                            :else false)
                                (break false)))
                        (let binding = (vec-find arg-bindings key-find arg.name))
                        (set (deref binding).b = (inst CapturedMacroArg
                            (type (CAPTURED_MACRO_ARG_REST))
                            (start i))))))

                (set ordered-arg = (+ ordered-arg 1))
                (while (and (: u64 (cast (let v = (vec-get (ref (deref macro).args) ordered-arg)))) (== (deref v).type (MACRO_ARG_TYPE_KEY))) (seqn
                    (set ordered-arg = (+ ordered-arg 1))))))

            (:else
                (break false)))
        (set i = (+ i 1)))
    :else (not (and (: u64 (cast (let arg = (vec-get (ref (deref macro).args) ordered-arg)))) (== (deref arg).type (MACRO_ARG_TYPE_ORDERED)))))))

(defun bind-macro-args (ast (* mut Ast)) (arg-bindings (* mut (Vec (Pair (@ mut u8) CapturedMacroArg)))) (old (* mut Ast))
    (cond
        ((== (deref ast).type (AST_NODE_TYPE_SYMBOL)) (seqn
            (let bound = (vec-find arg-bindings key-find (deref ast).value))
            (cond
                ((: u64 (cast bound)) (seqn
                    (let bound = (deref bound).b)
                    (cond
                        ((== bound.type (CAPTURED_MACRO_ARG_NONE)) (seqn
                            (set (deref ast) = (inst Ast
                                (type (AST_NODE_TYPE_SEXPR))
                                (loc (inst Location
                                    (start 0)
                                    (end 0)))
                                (typed (empty-type (deref arg-bindings).A))
                                (value "")
                                (children (new-vec (deref arg-bindings).A))))))
                        ((== bound.type (CAPTURED_MACRO_ARG_SINGLE)) (seqn
                            (set (deref ast) = (ast-clone (deref (vec-get (ref (deref old).children) (+ bound.start 1)))))))

                        ((== bound.type (CAPTURED_MACRO_ARG_REST)) (seqn
                            (eprint "&rest for macros is not implemented yet\n")
                            (exit 1)))))))))
        (:else (seqn
            (let i = 0)
            (while (< i (deref ast).children.len) (seqn
                (bind-macro-args (vec-get (ref (deref ast).children) i) arg-bindings old)
                (set i = (+ i 1))))))))

(defun replace-macros (map (* mut (Vec (Pair (@ mut u8) Macro)))) (ast (* mut Ast)) (seqn
    (cond
        ((== (deref ast).type (AST_NODE_TYPE_SEXPR)) (seqn
            (let sym = (vec-get (ref (deref ast).children) 0))
            (cond
                ((and (: u64 (cast sym)) (== (deref sym).type (AST_NODE_TYPE_SYMBOL)))
                    (cond
                        ((: u64 (cast (let macro = (vec-find map key-find (deref sym).value)))) (seqn
                            (let macro = (ref (deref macro).b))
                            (let arg-bindings = (ref (new-vec (deref map).A)))

                            (cond
                                ((macro-bind (subslice (vec-slice (ref (deref ast).children)) 1 (deref ast).children.len) macro arg-bindings) (seqn
                                    (let old = (deref ast))
                                    (set (deref ast) = (ast-clone (deref macro).body))
                                    (bind-macro-args ast arg-bindings (ref old))
                                    (ast-drop (ref old)))))))))))))

    (let i = 0)
    (while (< i (deref ast).children.len) (seqn
        (let child = (vec-get (ref (deref ast).children) i))
        (replace-macros map child)
        (set i = (+ i 1))))))



//
// ==================================================================================================
// TYPE CHECKING
// ==================================================================================================
//

(defmacro TYPE_TYPE_UNKNOWN        0)
(defmacro TYPE_TYPE_INT            1)
(defmacro TYPE_TYPE_F32            2)
(defmacro TYPE_TYPE_F64            3)
(defmacro TYPE_TYPE_TUPLE          4)
(defmacro TYPE_TYPE_POINTER        5)
(defmacro TYPE_TYPE_SLICE          6)
(defmacro TYPE_TYPE_STRUCT         7)
(defmacro TYPE_TYPE_GENERIC        8)
(defmacro TYPE_TYPE_FUNCTION       9)
(defmacro TYPE_TYPE_TYPE_VARIABLE 10)

// Defines a type
(defstruct Type
    (type u64)
    (signed-mutable u1)
    (subtypes (Vec Type))
    (boxed (* mut Type))
    (name (@ mut u8))
    (type-var-width u64))

(defun empty-type (A (* mut Allocator)) : Type
    (inst Type
        (type (TYPE_TYPE_UNKNOWN))
        (signed-mutable false)
        (subtypes (new-vec A))
        (boxed (null))
        (name "")
        (type-var-width 0)))

(defstruct Signature
    (arg-types (Vec Type))
    (ret-type Type)
    (index u64))

(defstruct TypeError
    (loc Location)
    (message (@ mut u8)))

(defun type-error (loc Location) (message (@ mut u8)) : TypeError
    (inst TypeError
        (loc loc)
        (message message)))

(defun parse-int (loc Location) (str (@ mut u8)) (errors (* mut (Vec TypeError))) : u64 (seq
    (let i = 0)
    (let n = 0)
    (while (< i str.len) (seqn
        (let c = (get str i))
        (cond
            ((and (<= '0' c) (<= c '9')) (seqn
                (set n = (+ (* n 10) (cast (- c '0'))))))
            (:else (seqn
                (vec-push errors (type-error loc "could not parse int type"))
                (break 0))))
        (set i = (+ i 1)))
    :else n)))

(defun parse-type (ast (* mut Ast)) (errors (* mut (Vec TypeError))) : Type (seq
    (let type = (ref (empty-type (deref errors).A)))
    (cond
        ((and (== (deref ast).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref ast).value "f32")) (seq
            (set (deref type).type = (TYPE_TYPE_F32))
            (deref type)))
        ((and (== (deref ast).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref ast).value "f64")) (seq
            (set (deref type).type = (TYPE_TYPE_F64))
            (deref type)))
        ((and (== (deref ast).type (AST_NODE_TYPE_SYMBOL)) (or (== (get (deref ast).value 0) 'i') (== (get (deref ast).value 0) 'u'))) (seq
            (set (deref type).type = (TYPE_TYPE_INT))
            (set (deref type).type-var-width = (parse-int (deref ast).loc (subslice (deref ast).value 1 (deref ast).value.len) errors))
            (set (deref type).signed-mutable = (== (get (deref ast).value 0) 'i'))
            (deref type)))
        ((== (deref ast).type (AST_NODE_TYPE_SYMBOL)) (seq
            (set (deref type).type = (TYPE_TYPE_STRUCT))
            (set (deref type).name = (deref ast).value)
            (deref type)))
        ((== (deref ast).type (AST_NODE_TYPE_QUOTE)) (seq
            (let child = (vec-get (ref (deref ast).children) 0))
            (cond
                ((== (deref child).type (AST_NODE_TYPE_SYMBOL)) (seqn
                    (set (deref type).type = (TYPE_TYPE_GENERIC))
                    (set (deref type).name = (deref child).value)))
                ((== (deref child).type (AST_NODE_TYPE_SEXPR)) (seqn
                    (set (deref type).type = (TYPE_TYPE_TUPLE))
                    (let i = 0)
                    (let v = (ref (deref type).subtypes))
                    (while (< i (deref child).children.len) (seqn
                        (vec-push v (parse-type (vec-get (ref (deref child).children) i) errors))
                        (set i = (+ i 1))))
                    (set (deref type).subtypes = (deref v))))
                (:else
                    (vec-push errors (type-error (deref child).loc "could not parse quoted type"))))
            (deref type)))

        ((and (== (deref ast).type (AST_NODE_TYPE_SEXPR)) (== (deref ast).children.len 0)) (seq
            (set (deref type).type = (TYPE_TYPE_TUPLE))
            (deref type)))

        ((== (deref ast).type (AST_NODE_TYPE_SEXPR)) (seq
            (let first = (vec-get (ref (deref ast).children) 0))
            (cond
                ((== (deref first).type (AST_NODE_TYPE_SYMBOL))
                    (cond
                        ((str-equals (deref first).value "*")
                            (cond
                                ((and (== (deref ast).children.len 3) (and (== (let v = (deref (vec-get (ref (deref ast).children) 1))).type (AST_NODE_TYPE_SYMBOL)) (str-equals v.value "mut"))) (seqn
                                    (set (deref type).type = (TYPE_TYPE_POINTER))
                                    (set (deref type).signed-mutable = true)
                                    (set (deref type).boxed = (alloc (deref ast).children.A))
                                    (set (deref (deref type).boxed) = (parse-type (vec-get (ref (deref ast).children) 2) errors))))

                                ((== (deref ast).children.len 2) (seqn
                                    (set (deref type).type = (TYPE_TYPE_POINTER))
                                    (set (deref type).signed-mutable = false)
                                    (set (deref type).boxed = (alloc (deref ast).children.A))
                                    (set (deref (deref type).boxed) = (parse-type (vec-get (ref (deref ast).children) 2) errors))))

                                (:else
                                    (vec-push errors (type-error (deref ast).loc "could not parse pointer type")))))

                        ((str-equals (deref first).value "@")
                            (cond
                                ((and (== (deref ast).children.len 3) (and (== (let v = (deref (vec-get (ref (deref ast).children) 1))).type (AST_NODE_TYPE_SYMBOL)) (str-equals v.value "mut"))) (seqn
                                    (set (deref type).type = (TYPE_TYPE_SLICE))
                                    (set (deref type).signed-mutable = true)
                                    (set (deref type).boxed = (alloc (deref ast).children.A))
                                    (set (deref (deref type).boxed) = (parse-type (vec-get (ref (deref ast).children) 2) errors))))

                                ((== (deref ast).children.len 2) (seqn
                                    (set (deref type).type = (TYPE_TYPE_SLICE))
                                    (set (deref type).signed-mutable = false)
                                    (set (deref type).boxed = (alloc (deref ast).children.A))
                                    (set (deref (deref type).boxed) = (parse-type (vec-get (ref (deref ast).children) 2) errors))))

                                (:else
                                    (vec-push errors (type-error (deref ast).loc "could not parse slice type")))))

                        ((str-equals (deref first).value "fn")
                            (cond
                                ((>= (deref ast).children.len 2) (seqn
                                    (let arg-types = (ref (new-vec (deref ast).children.A)))
                                    (let args = (vec-get (ref (deref ast).children) 1))
                                    (cond
                                        ((== (deref args).type (AST_NODE_TYPE_SEXPR)) (seqn
                                            (let i = 0)
                                            (while (< i (deref args).children.len) (seqn
                                                (vec-push arg-types (parse-type (vec-get (ref (deref args).children) i) errors))
                                                (set i = (+ i 1))))))
                                        (:else
                                            (vec-push errors (type-error (deref ast).loc "could not parse function arg types"))))

                                    (let ret-type = (ref (empty-type (deref args).children.A)))
                                    (cond
                                        ((and (== (deref ast).children.len 4) (and (== (deref (let v = (vec-get (ref (deref ast).children) 2))).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref v).value ":"))) (seqn
                                            (set (deref ret-type) = (parse-type (vec-get (ref (deref ast).children) 3) errors))))
                                        ((== (deref ast).children.len 2) (seqn
                                            (set (deref ret-type).type = (TYPE_TYPE_TUPLE))))
                                        (:else
                                            (vec-push errors (type-error (deref ast).loc "could not parse function return type"))))
                                    (set (deref type).type = (TYPE_TYPE_FUNCTION))
                                    (set (deref type).subtypes = (deref arg-types))
                                    (set (deref type).boxed = (alloc (deref args).children.A))
                                    (set (deref (deref type).boxed) = (deref ret-type))
                                    ))
                                (:else
                                    (vec-push errors (type-error (deref ast).loc "could not parse function type")))))

                        (:else (seqn
                            (set (deref type).type = (TYPE_TYPE_STRUCT))
                            (set (deref type).name = (deref first).value)
                            (let i = 1)
                            (let subtypes-ref = (ref (deref type).subtypes))
                            (while (< i (deref ast).children.len) (seqn
                                (vec-push subtypes-ref (parse-type (vec-get (ref (deref ast).children) i) errors))
                                (set i = (+ i 1))))
                            (set (deref type).subtypes = (deref subtypes-ref))))))

                (:else
                    (vec-push errors (type-error (deref ast).loc "could not parse parenthesised type type"))))
            (deref type)))

        (:else (seq
            (vec-push errors (type-error (deref ast).loc "could not parse type"))
            (deref type))))))

(defun extract-functions (ast (* mut Ast)) (result (* mut (Vec (Pair (@ mut u8) Signature)))) (errors (* mut (Vec TypeError))) (seqn
    (let i = 0)
    (while (< i (deref ast).children.len) (seqn
        (let ast = (vec-get (ref (deref ast).children) i))
        (cond
            ((and (== (deref ast).type (AST_NODE_TYPE_SEXPR)) (>= (deref ast).children.len 3)) (seqn
                (let defun = (vec-get (ref (deref ast).children) 0))
                (cond
                    ((and (== (deref defun).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref defun).value "defun")) (seqn
                        (let name = (vec-get (ref (deref ast).children) 1))
                        (cond
                            ((== (deref name).type (AST_NODE_TYPE_SYMBOL)) (seqn
                                (let name = (deref name).value)
                                (let colon? = (vec-get (ref (deref ast).children) (- (deref ast).children.len 3)))
                                (let has-ret-type = (and (== (deref colon?).type (AST_NODE_TYPE_SYMBOL)) (str-equals (deref colon?).value ":")))

                                (let ret-type = (cond
                                    (has-ret-type (seq
                                        (let type-ast = (vec-get (ref (deref ast).children) (- (deref ast).children.len 2)))
                                        (parse-type type-ast errors)))
                                    (:else (seq
                                        (let type = (ref (empty-type (deref ast).children.A)))
                                        (set (deref type).type = (TYPE_TYPE_TUPLE))
                                        (deref type)))))

                                (let j = 2)
                                (let args = (ref (new-vec (deref ast).children.A)))
                                (let last = (- (deref ast).children.len (cond
                                    (has-ret-type 3)
                                    (:else 1))))
                                (while (< j last) (seqn
                                    (let child = (vec-get (ref (deref ast).children) j))
                                    (cond
                                        ((and (== (deref child).type (AST_NODE_TYPE_SEXPR)) (== (deref child).children.len 2)) (seqn
                                            (let arg = (vec-get (ref (deref child).children) 0))
                                            (cond
                                                ((!= (deref arg).type (AST_NODE_TYPE_SYMBOL))
                                                    (vec-push errors (type-error (deref arg).loc "invalid function argument"))))
                                            (let type = (vec-get (ref (deref child).children) 1))
                                            (vec-push args (parse-type type errors))))
                                        (:else
                                            (vec-push errors (type-error (deref child).loc "invalid function argument"))))
                                    (set j = (+ j 1))))
                                (cond
                                    ((: u64 (cast (vec-find result key-find name)))
                                        (vec-push errors (type-error (deref ast).loc "function defined twice")))
                                    (:else
                                        (vec-push result (inst Pair
                                            (a name)
                                            (b (inst Signature
                                                (arg-types (deref args))
                                                (ret-type ret-type)
                                                (index i))))))))))))))))
        (set i = (+ i 1))))))

(defun print-type (type (* mut Type))
    (cond
        ((== (deref type).type (TYPE_TYPE_UNKNOWN))
            (print "<unknown>"))
        ((== (deref type).type (TYPE_TYPE_INT)) (seqn
            (cond
                ((deref type).signed-mutable
                    (print "i"))
                (:else
                    (print "u")))
            (print-int (deref type).type-var-width)))
        ((== (deref type).type (TYPE_TYPE_F32))
            (print "f32"))
        ((== (deref type).type (TYPE_TYPE_F64))
            (print "f64"))
        ((== (deref type).type (TYPE_TYPE_TUPLE)) (seqn
            (print "'(")
            (let i = 0)
            (while (< i (deref type).subtypes.len) (seqn
                (cond
                    ((!= i 0)
                        (print " ")))
                (print-type (vec-get (ref (deref type).subtypes) i))
                (set i = (+ i 1))))
            (print ")")))
        ((== (deref type).type (TYPE_TYPE_POINTER)) (seqn
            (cond
                ((deref type).signed-mutable
                    (print "(*mut "))
                (:else
                    (print "(* ")))
            (print-type (deref type).boxed)
            (print ")")))
        ((== (deref type).type (TYPE_TYPE_SLICE)) (seqn
            (cond
                ((deref type).signed-mutable
                    (print "(@mut "))
                (:else
                    (print "(@ ")))
            (print-type (deref type).boxed)
            (print ")")))
        ((== (deref type).type (TYPE_TYPE_STRUCT)) (seqn
            (cond
                ((deref type).subtypes.len
                    (print "(")))
            (print (deref type).name)
            (let i = 0)
            (while (< i (deref type).subtypes.len) (seqn
                (print " ")
                (print-type (vec-get (ref (deref type).subtypes) i))
                (set i = (+ i 1))))
            (cond
                ((deref type).subtypes.len
                    (print ")")))))
        ((== (deref type).type (TYPE_TYPE_GENERIC)) (seqn
            (print "'")
            (print (deref type).name)))
        ((== (deref type).type (TYPE_TYPE_FUNCTION)) (seqn
            (print "(fn (")
            (let i = 0)
            (while (< i (deref type).subtypes.len) (seqn
                (cond
                    ((!= i 0)
                        (print " ")))
                (print-type (vec-get (ref (deref type).subtypes) i))
                (set i = (+ i 1))))
            (print ") : ")
            (print-type (deref type).boxed)
            (print ")")))
        ((== (deref type).type (TYPE_TYPE_TYPE_VARIABLE)) (seqn
            (print "$")
            (print-int (deref type).type-var-width)))
        (:else
            (print "UNKNOWN"))))

(defun print-signatures (func-map (* mut (Vec (Pair (@ mut u8) Signature)))) (seqn
    (let i = 0)
    (while (< i (deref func-map).len) (seqn
        (let func = (vec-get func-map i))
        (print (deref func).a)
        (print ": (")
        (let j = 0)
        (while (< j (deref func).b.arg-types.len) (seqn
            (cond
                ((!= j 0)
                    (print " ")))
            (print-type (vec-get (ref (deref func).b.arg-types) j))
            (set j = (+ j 1))))
        (print ") : ")
        (print-type (ref (deref func).b.ret-type))
        (print "\n")
        (set i = (+ i 1))))))

(defmacro COERCION_TYPE_NONE   0)
(defmacro COERCION_TYPE_INT    1)
(defmacro COERCION_TYPE_FLOAT  2)

(defun type-clone (type (* mut Type)) : Type (seq
    (let new = (ref (empty-type (deref type).subtypes.A)))
    (set (deref new).type = (deref type).type)
    (set (deref new).signed-mutable = (deref type).signed-mutable)
    (let i = 0)
    (let subtypes = (ref (deref new).subtypes))
    (while (< i (deref type).subtypes.len) (seqn
        (vec-push subtypes (type-clone (vec-get (ref (deref type).subtypes) i)))
        (set i = (+ i 1))))
    (set (deref new).subtypes = (deref subtypes))
    (cond
        ((: u64 (cast (deref type).boxed)) (seqn
            (set (deref new).boxed = (alloc (deref type).subtypes.A))
            (set (deref (deref new).boxed) = (type-clone (deref type).boxed)))))
    (set (deref new).name = (deref type).name)
    (set (deref new).type-var-width = (deref type).type-var-width)
    (deref new)))

(defun type-equals (a Type) (b Type) : u1
    (cond
        ((== a.type b.type)
            (cond
                ((== a.type (TYPE_TYPE_INT))
                    (and (== a.signed-mutable b.signed-mutable) (== a.type-var-width b.type-var-width)))
                ((== a.type (TYPE_TYPE_TUPLE))
                    (and (== a.subtypes.len b.subtypes.len) (seq
                        (let i = 0)
                        (while (< i a.subtypes.len) (seqn
                            (let a = (vec-get (ref a.subtypes) i))
                            (let b = (vec-get (ref b.subtypes) i))
                            (cond
                                ((not (type-equals (deref a) (deref b)))
                                    (break false)))
                            (set i = (+ i 1)))
                        :else true))))
                ((or (== a.type (TYPE_TYPE_POINTER)) (== a.type (TYPE_TYPE_SLICE)))
                    (and (== a.signed-mutable b.signed-mutable) (type-equals (deref a.boxed) (deref b.boxed))))
                ((== a.type (TYPE_TYPE_STRUCT))
                    (and (and (str-equals a.name b.name) (== a.subtypes.len b.subtypes.len)) (seq
                        (let i = 0)
                        (while (< i a.subtypes.len) (seqn
                            (let a = (vec-get (ref a.subtypes) i))
                            (let b = (vec-get (ref b.subtypes) i))
                            (cond
                                ((not (type-equals (deref a) (deref b)))
                                    (break false)))
                            (set i = (+ i 1)))
                        :else true))))
                ((== a.type (TYPE_TYPE_GENERIC))
                    (str-equals a.name b.name))
                ((== a.type (TYPE_TYPE_FUNCTION))
                    (and (and (type-equals (deref a.boxed) (deref b.boxed)) (== a.subtypes.len b.subtypes.len)) (seq
                        (let i = 0)
                        (while (< i a.subtypes.len) (seqn
                            (let a = (vec-get (ref a.subtypes) i))
                            (let b = (vec-get (ref b.subtypes) i))
                            (cond
                                ((not (type-equals (deref a) (deref b)))
                                    (break false)))
                            (set i = (+ i 1)))
                        :else true))))
                ((== a.type (TYPE_TYPE_TYPE_VARIABLE))
                    (== a.type-var-width b.type-var-width))
                (:else true)))
        (:else false)))

(defun get-type-leaf (type (* mut Type)) (substitutions (* mut (Vec (Pair Type u64)))) (seqn
    (while (== (deref type).type (TYPE_TYPE_TYPE_VARIABLE)) (seqn
        (let new = (deref (vec-get substitutions (deref type).type-var-width)).a)
        (cond
            ((and (== new.type (TYPE_TYPE_TYPE_VARIABLE)) (== new.type-var-width (deref type).type-var-width))
                (break)))
        (set (deref type) = new)))))

(defun substitute (loc Location) (assignee (* mut Type)) (assigner (* mut Type)) (substitutions (* mut (Vec (Pair Type u64)))) (errors (* mut (Vec TypeError))) (seqn
    (get-type-leaf assignee substitutions)
    (get-type-leaf assigner substitutions)
    (cond
        ((type-equals (deref assignee) (deref assigner))
            ())

        ((== (deref assignee).type (TYPE_TYPE_UNKNOWN)) (seqn
            (set (deref assignee) = (type-clone assigner))))

        ((== (deref assignee).type (TYPE_TYPE_TYPE_VARIABLE)) (seqn
            (let coercion = (deref (vec-get substitutions (deref assignee).type-var-width)).b)
            (let assign = (cond
                ((and (== coercion (COERCION_TYPE_INT)) (== (deref assigner).type (TYPE_TYPE_INT)))
                    true)
                ((and (== coercion (COERCION_TYPE_FLOAT)) (or (== (deref assigner).type (TYPE_TYPE_F32)) (== (deref assigner).type (TYPE_TYPE_F32))))
                    true)
                ((== coercion (COERCION_TYPE_NONE))
                    true)
                ((== (deref assigner).type (TYPE_TYPE_TYPE_VARIABLE)) (seq
                    (let pair = (vec-get substitutions (deref assigner).type-var-width))
                    (cond
                        ((== (deref pair).b (COERCION_TYPE_NONE)) (seq
                            (set (deref pair).b = coercion)
                            true))
                        ((== (deref pair).b coercion)
                            true)
                        (:else (seq
                            (vec-push errors (type-error loc "type cannot be coerced"))
                            false)))))
                (:else (seq
                    (vec-push errors (type-error loc "type cannot be coerced"))
                    false))))
            (cond
                (assign (seqn
                    (let v = (vec-get substitutions (deref assignee).type-var-width))
                    (set (deref v).a = (type-clone assigner))
                    (set (deref assignee) = (deref assigner)))))))

        ((== (deref assigner).type (TYPE_TYPE_TYPE_VARIABLE)) (seqn
            (let coercion = (deref (vec-get substitutions (deref assigner).type-var-width)).b)
            (let assign = (cond
                ((and (== coercion (COERCION_TYPE_INT)) (== (deref assignee).type (TYPE_TYPE_INT)))
                    true)
                ((and (== coercion (COERCION_TYPE_FLOAT)) (or (== (deref assignee).type (TYPE_TYPE_F32)) (== (deref assignee).type (TYPE_TYPE_F32))))
                    true)
                ((== coercion (COERCION_TYPE_NONE))
                    true)
                ((== (deref assignee).type (TYPE_TYPE_TYPE_VARIABLE)) (seq
                    (let pair = (vec-get substitutions (deref assignee).type-var-width))
                    (cond
                        ((== (deref pair).b (COERCION_TYPE_NONE)) (seq
                            (set (deref pair).b = coercion)
                            true))
                        ((== (deref pair).b coercion)
                            true)
                        (:else (seq
                            (vec-push errors (type-error loc "type cannot be coerced"))
                            false)))))
                (:else (seq
                    (vec-push errors (type-error loc "type cannot be coerced"))
                    false))))
            (cond
                (assign (seqn
                    (let v = (vec-get substitutions (deref assigner).type-var-width))
                    (set (deref v).a = (type-clone assignee)))))))

        ((type-equals (deref assignee) (deref assigner))
            ())

        ((== (deref assignee).type (deref assigner).type)
            (cond
                ((== (deref assignee).type (TYPE_TYPE_TUPLE))
                    (cond
                        ((!= (deref assignee).subtypes.len (deref assigner).subtypes.len)
                            (vec-push errors (type-error loc "tuple types have incompatible lengths")))
                        (:else (seqn
                            (let i = 0)
                            (while (< i (deref assignee).subtypes.len) (seqn
                                (let assignee = (vec-get (ref (deref assignee).subtypes) i))
                                (let assigner = (ref (deref (vec-get (ref (deref assigner).subtypes) i))))
                                (substitute loc assignee assigner substitutions errors)
                                (set i = (+ i 1))))))))

                ((or (== (deref assignee).type (TYPE_TYPE_POINTER)) (== (deref assignee).type (TYPE_TYPE_SLICE)))
                    (substitute loc (deref assignee).boxed (ref (deref (deref assigner).boxed)) substitutions errors))

                ((== (deref assignee).type (TYPE_TYPE_STRUCT))
                    (cond
                        ((not (str-equals (deref assignee).name (deref assigner).name))
                            (vec-push errors (type-error loc "incompatible struct types")))
                        ((!= (deref assignee).subtypes.len (deref assigner).subtypes.len)
                            (vec-push errors (type-error loc "struct types have incompatible lengths")))
                        (:else (seqn
                            (let i = 0)
                            (while (< i (deref assignee).subtypes.len) (seqn
                                (let assignee = (vec-get (ref (deref assignee).subtypes) i))
                                (let assigner = (ref (deref (vec-get (ref (deref assigner).subtypes) i))))
                                (substitute loc assignee assigner substitutions errors)
                                (set i = (+ i 1))))))))

                ((== (deref assignee).type (TYPE_TYPE_FUNCTION))
                    (cond
                        ((!= (deref assignee).subtypes.len (deref assigner).subtypes.len)
                            (vec-push errors (type-error loc "function types have incompatible arg numbers")))
                        (:else (seqn
                            (let i = 0)
                            (while (< i (deref assignee).subtypes.len) (seqn
                                (let assignee = (vec-get (ref (deref assignee).subtypes) i))
                                (let assigner = (ref (deref (vec-get (ref (deref assigner).subtypes) i))))
                                (substitute loc assignee assigner substitutions errors)
                                (set i = (+ i 1))))
                            (substitute loc (deref assignee).boxed (ref (deref (deref assigner).boxed)) substitutions errors)))))))

        (:else
            (vec-push errors (type-error loc "the given types cannot be unified"))))))

(defun check-ast
    (ast (* mut Ast))
    (errors (* mut (Vec TypeError)))
    (substitutions (* mut (Vec (Pair Type u64))))
    (func-map (* mut (Vec (Pair (@ mut u8) Signature))))
    (monomorphisms (* mut (Vec (Pair Type u64))))
    (scopes (* mut (Vec (Vec (Pair (@ mut u8) Type)))))
    (break-type (* mut Type))
    (cond
        ((== (deref ast).type (AST_NODE_TYPE_ROOT)) (seqn
            (let i = 0)
            (while (< i (deref ast).children.len) (seqn
                (check-ast (vec-get (ref (deref ast).children) i) errors substitutions func-map monomorphisms scopes break-type)
                (set i = (+ i 1))))))

        ((== (deref ast).type (AST_NODE_TYPE_SEXPR))
            (cond
                ((not (deref ast).children.len) (seqn
                    (set (deref ast).typed = (empty-type (deref errors).A))
                    (set (deref ast).typed.type = (TYPE_TYPE_TUPLE))))

                ((and (== (let v = (deref (vec-get (ref (deref ast).children) 0))).type (AST_NODE_TYPE_SYMBOL)) (str-equals v.value "defmacro"))
                    ())

                ((and (== (let v = (deref (vec-get (ref (deref ast).children) 0))).type (AST_NODE_TYPE_SYMBOL)) (str-equals v.value "defun")) (seqn
                    // function definition is guaranteed to be well formed at top level
                    // TODO: verify function definitions at lower levels
                    (let name = (deref (vec-get (ref (deref ast).children) 1)).value)
                    (let func = (vec-find func-map key-find name))
                    (let body = (vec-get (ref (deref ast).children) (- (deref ast).children.len 1)))
                    (let v = (ref (new-vec (deref errors).A)))
                    (let i = 0)
                    (while (< i (deref func).b.arg-types.len) (seqn
                        (let arg = (vec-get (ref (deref ast).children) (+ i 2)))
                        (let arg = (vec-get (ref (deref arg).children) 0))
                        (let arg = (deref arg).value)
                        (let type = (vec-get (ref (deref func).b.arg-types) i))
                        (vec-push v (inst Pair
                            (a arg)
                            (b (deref type))))
                        (set i = (+ i 1))))
                    (vec-push scopes (deref v))

                    (check-ast body errors substitutions func-map monomorphisms scopes break-type)
                    (vec-pop scopes)
                    (let type = (ref (deref body).typed))
                    (substitute (deref body).loc type (ref (deref func).b.ret-type) substitutions errors)
                    (set (deref body).typed = (deref type))))

                ((and (== (let v = (deref (vec-get (ref (deref ast).children) 0))).type (AST_NODE_TYPE_SYMBOL)) (str-equals v.value "seqn"))
                    (cond
                        ((> (deref ast).children.len 1) (seqn
                            (let i = 1)
                            (while (< i (deref ast).children.len) (seqn
                                (check-ast (vec-get (ref (deref ast).children) i) errors substitutions func-map monomorphisms scopes break-type)
                                (set i = (+ i 1))))
                            (set (deref ast).typed = (empty-type (deref errors).A))
                            (set (deref ast).typed.type = (TYPE_TYPE_TUPLE))))
                        (:else (seqn
                            (vec-push errors (type-error (deref ast).loc "seqn must have one or more arguments"))))))

                ((and (== (let v = (deref (vec-get (ref (deref ast).children) 0))).type (AST_NODE_TYPE_SYMBOL)) (str-equals v.value "seq"))
                    (cond
                        ((> (deref ast).children.len 1) (seqn
                            (let i = 1)
                            (while (< i (deref ast).children.len) (seqn
                                (check-ast (vec-get (ref (deref ast).children) i) errors substitutions func-map monomorphisms scopes break-type)
                                (set i = (+ i 1))))
                            (set (deref ast).typed = (deref (vec-get (ref (deref ast).children) (- i 1))).typed)))
                        (:else (seqn
                            (vec-push errors (type-error (deref ast).loc "seq must have one or more arguments"))))))

                ((and (== (let v = (deref (vec-get (ref (deref ast).children) 0))).type (AST_NODE_TYPE_SYMBOL)) (str-equals v.value "loop"))
                    (cond
                        ((== (deref ast).children.len 2) (seqn
                            (let break-type = (ref (empty-type (deref errors).A)))
                            (check-ast (vec-get (ref (deref ast).children) 1) errors substitutions func-map monomorphisms scopes break-type)
                            (cond
                                ((== (deref break-type).type (TYPE_TYPE_UNKNOWN)) (seqn
                                    (set (deref break-type).type = (TYPE_TYPE_TUPLE)))))
                            (set (deref ast).typed = (deref break-type))))
                        (:else
                            (vec-push errors (type-error (deref ast).loc "loop must have only one argument")))))

                ((and (== (let v = (deref (vec-get (ref (deref ast).children) 0))).type (AST_NODE_TYPE_SYMBOL)) (str-equals v.value "break")) (seqn
                    (let type = (cond
                        ((== (deref ast).children.len 2) (seq
                            (let value = (vec-get (ref (deref ast).children) 1))
                            (check-ast value errors substitutions func-map monomorphisms scopes break-type)
                            (deref value).typed))
                        ((== (deref ast).children.len 1) (seq
                            (let t = (ref (empty-type (deref errors).A)))
                            (set (deref t).type = (TYPE_TYPE_TUPLE))
                            (deref t)))
                        (:else (seq
                            (vec-push errors (type-error (deref ast).loc "break type does not match previous break type"))
                            (empty-type (deref errors).A)))))
                    (substitute (deref ast).loc break-type (ref type) substitutions errors)))

                (:else (seqn
                    (let i = 0)
                    (while (< i (deref ast).children.len) (seqn
                        (let v = (vec-get (ref (deref ast).children) i))
                        (check-ast v errors substitutions func-map monomorphisms scopes break-type)
                        (set i = (+ i 1))))
                    (let func = (vec-get (ref (deref ast).children) 0))
                    (cond
                        ((== (deref func).typed.type (TYPE_TYPE_FUNCTION))
                            (cond
                                ((== (deref func).typed.subtypes.len (- i 1)) (seqn
                                    (let i = 0)
                                    (while (< i (deref func).typed.subtypes.len) (seqn
                                        (let arg = (vec-get (ref (deref ast).children) (+ i 1)))
                                        (let t = (ref (deref arg).typed))
                                        (substitute (deref arg).loc t (vec-get (ref (deref func).typed.subtypes) i) substitutions errors)
                                        (set (deref arg).typed = (deref t))
                                        (set i = (+ i 1))))
                                    (set (deref ast).typed = (type-clone (deref func).typed.boxed))))
                                (:else
                                    (vec-push errors (type-error (deref ast).loc "function argument count does not match provided argument count")))))
                        (:else
                            (vec-push errors (type-error (deref func).loc "value is not a function"))))))))

        ((== (deref ast).type (AST_NODE_TYPE_INT)) (seqn
            (let type = (ref (empty-type (deref errors).A)))
            (set (deref type).type = (TYPE_TYPE_TYPE_VARIABLE))
            (set (deref type).type-var-width = (deref substitutions).len)
            (vec-push substitutions (inst Pair
                (a (deref type))
                (b (COERCION_TYPE_INT))))
            (set (deref ast).typed = (deref type))))

        ((== (deref ast).type (AST_NODE_TYPE_CHAR)) (seqn
            (let type = (ref (empty-type (deref errors).A)))
            (set (deref type).type = (TYPE_TYPE_INT))
            (set (deref type).type-var-width = 8)
            (set (deref type).signed-mutable = false)
            (set (deref ast).typed = (deref type))))

        ((== (deref ast).type (AST_NODE_TYPE_STRING)) (seqn
            (let type = (ref (empty-type (deref errors).A)))
            (set (deref type).type = (TYPE_TYPE_SLICE))
            (set (deref type).signed-mutable = false)
            (set (deref type).boxed = (alloc (deref errors).A))
            (let subtype = (ref (empty-type (deref errors).A)))
            (set (deref subtype).type = (TYPE_TYPE_INT))
            (set (deref subtype).type-var-width = 8)
            (set (deref subtype).signed-mutable = false)
            (set (deref (deref type).boxed) = (deref subtype))
            (set (deref ast).typed = (deref type))))

        ((== (deref ast).type (AST_NODE_TYPE_SYMBOL)) (seqn
            (let i = (deref scopes).len)
            (set (deref ast).typed = (while (!= i 0) (seqn
                (set i = (- i 1))
                (let scope = (vec-get scopes i))
                (let v = (vec-find scope key-find (deref ast).value))
                (cond
                    ((: u64 (cast v))
                        (break (deref v).b))))
            :else (seq
                (let v = (vec-find func-map key-find (deref ast).value))
                (cond
                    ((: u64 (cast v)) (seq
                        (let v = (deref v).b)
                        (let type = (ref (empty-type (deref errors).A)))
                        (set (deref type).type = (TYPE_TYPE_FUNCTION))
                        (set (deref type).boxed = (alloc (deref errors).A))
                        (set (deref (deref type).boxed) = v.ret-type)
                        (let i = 0)
                        (let subtypes = (ref (deref type).subtypes))
                        (while (< i v.arg-types.len) (seqn
                            (vec-push subtypes (deref (vec-get (ref v.arg-types) i)))
                            (set i = (+ i 1))))
                        (set (deref type).subtypes = (deref subtypes))
                        (deref type)))
                    (:else (seq
                        (vec-push errors (type-error (deref ast).loc "undefined symbol"))
                        (empty-type (deref errors).A)))))))))

        ((== (deref ast).type (AST_NODE_TYPE_KEY))
            (vec-push errors (type-error (deref ast).loc "invalid usage of key")))

        ((== (deref ast).type (AST_NODE_TYPE_QUOTE))
            (vec-push errors (type-error (deref ast).loc "invalid usage of quote")))

        ((== (deref ast).type (AST_NODE_TYPE_ATTR))
            (vec-push errors (type-error (deref ast).loc "attributes are not implemented yet")))

        (:else (seqn
            (eprint "todo: checking ast type ")
            (eprint-int (deref ast).type)
            (eprint " is currently unimplemented\n")
            (exit 1)))))

(defun flatten-substitution (type (* mut Type)) (errors (* mut (Vec TypeError))) (loc Location) (substitutions (* mut (Vec (Pair Type u64))))
    (cond
        ((== (deref type).type (TYPE_TYPE_TYPE_VARIABLE)) (seqn
            (let type2 = (deref (vec-get substitutions (deref type).type-var-width)).a)
            (cond
                ((and (== type2.type (TYPE_TYPE_TYPE_VARIABLE)) (== type2.type-var-width (deref type).type-var-width))
                    (vec-push errors (type-error loc "unassigned type variable")))
                (:else (seqn
                    (set (deref type) = type2)
                    (flatten-substitution type errors loc substitutions))))))))

(defun apply-substitutions (ast (* mut Ast)) (errors (* mut (Vec TypeError))) (substitutions (* mut (Vec (Pair Type u64)))) (seqn
    (let type = (ref (deref ast).typed))
    (flatten-substitution type errors (deref ast).loc substitutions)
    (set (deref ast).typed = (deref type))
    (let i = 0)
    (while (< i (deref ast).children.len) (seqn
        (apply-substitutions (vec-get (ref (deref ast).children) i) errors substitutions)
        (set i = (+ i 1))))))

(defun check (ast (* mut Ast)) (errors (* mut (Vec TypeError))) (func-map (* mut (Vec (Pair (@ mut u8) Signature)))) (seqn
    (let skip = 0)
    //(let done = (new-vec (deref errors).A))
    (while (seq
        (let monomorphisms = (ref (new-vec (deref errors).A)))
        (let scopes = (ref (new-vec (deref errors).A)))

        (let substitutions = (ref (new-vec (deref errors).A)))
        (check-ast ast errors substitutions func-map // struct-map 
        monomorphisms scopes (null)
        )

        (let i = 0)
        (while (< i (deref substitutions).len) (seqn
            (let pair = (vec-get substitutions i))
            (let type = (deref pair).a)
            (let coercion = (deref pair).b)
            (cond
                ((and (== coercion (COERCION_TYPE_INT)) (== type.type (TYPE_TYPE_TYPE_VARIABLE))) (seqn
                    (set type = (empty-type (deref errors).A))
                    (set type.type = (TYPE_TYPE_INT))
                    (set type.type-var-width = 32)
                    (set type.signed-mutable = true)))
                ((and (== coercion (COERCION_TYPE_INT)) (== type.type (TYPE_TYPE_INT)))
                    ())

                ((and (== coercion (COERCION_TYPE_FLOAT)) (== type.type (TYPE_TYPE_TYPE_VARIABLE))) (seqn
                    (set type = (empty-type (deref errors).A))
                    (set type.type = (TYPE_TYPE_F64))))
                ((and (== coercion (COERCION_TYPE_FLOAT)) (or (== type.type (TYPE_TYPE_F32)) (== type.type (TYPE_TYPE_F64))))
                    ()))
            (set (deref pair).a = type)
            (set i = (+ i 1))))

        (apply-substitutions ast errors substitutions)

        false) ())))

(defun print-type-errors (contents (@ mut u8)) (errors (* mut (Vec TypeError))) (seqn
    (let i = 0)
    (while (< i (deref errors).len) (seqn
        (let error = (deref (vec-get errors i)))
        (eprint "error: ")
        (eprint error.message)
        (let line-col = (loc-to-line-col contents error.loc))
        (eprint " (")
        (eprint-int line-col.line-start)
        (eprint ":")
        (eprint-int line-col.col-start)
        (eprint "..")
        (eprint-int line-col.line-end)
        (eprint ":")
        (eprint-int line-col.col-end)
        (eprint ")\n")
        (set i = (+ i 1))))
    (cond
        (i (exit 1)))))



//
// ==================================================================================================
// MAIN
// ==================================================================================================
//

(defun main (argv (* mut (* mut u8))) (argc u64)
    (seqn
        (let filename = (get-argv argv 1))
        (cond
            ((== filename.ptr (null)) (seqn
                (eprint "please provide a file to compile\n")
                (exit 1))))
        (let file = (file-open filename (FILE_OPEN_FLAG_READ_ONLY)))
        (cond
            ((not (file-is-valid file)) (seqn
                (eprint "error: failed to open file ")
                (eprint filename)
                (eprint "\n")
                (exit 1))))
        (let A = (ref (new-alloc)))
        (let contents = (file-read-all file A))
        (let contents-ref = (vec-slice (ref contents)))
        (file-close file)
        (let lexer = (ref (new-lexer A contents-ref)))
        (let result = (parse lexer))
        (cond (result.success (seq
            (let ast = (ref result.ast))
            (let macros = (ref (new-vec A)))
            (extract-macros macros ast)
            (replace-macros macros ast)
            (let func-map = (ref (new-vec A)))
            (let errors = (ref (new-vec A)))
            (extract-functions ast func-map errors)
            (print-type-errors contents-ref errors)
            (check ast errors func-map)
            (print-type-errors contents-ref errors)
            (print-ast ast)
            (ast-drop ast)
            (vec-drop macros empty-dealloc)))
        (:else (print-parse-error contents-ref (ref result.fail))))
        (lexer-drop lexer)
        (vec-drop (ref contents) empty-dealloc)))

